; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;344      */
;;;345    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;346    {
;;;347        uint32_t u32PllFreq = 0, u32PllReg;
;;;348        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;349        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a012              ADR      r0,|L1.76|
000004  6800              LDR      r0,[r0,#0]
;;;350    
;;;351        u32PllReg = CLK->PLLCTL;
000006  9000              STR      r0,[sp,#0]
000008  4811              LDR      r0,|L1.80|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;352    
;;;353        if (u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;354            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;355    
;;;356        if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC_DIV2)
;;;357            u32FIN = __HIRC_DIV2;    /* PLL source clock from HIRC_DIV2 */
;;;358        else
;;;359            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;360    
;;;361        if (u32PllReg & CLK_PLLCTL_BP_Msk)
;;;362            return u32FIN;      /* PLL is in bypass mode */
;;;363    
;;;364        /* PLL is output enabled in normal work mode */
;;;365        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;366        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;367        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;368    
;;;369        /* u32FIN is shifted 2 bits to avoid overflow */
;;;370        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;371    
;;;372        return u32PllFreq;
;;;373    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  2011              MOVS     r0,#0x11              ;356
000018  04c0              LSLS     r0,r0,#19             ;356
00001a  4201              TST      r1,r0                 ;356
00001c  d001              BEQ      |L1.34|
00001e  480d              LDR      r0,|L1.84|
000020  e000              B        |L1.36|
                  |L1.34|
000022  480d              LDR      r0,|L1.88|
                  |L1.36|
000024  038a              LSLS     r2,r1,#14             ;361
000026  d4f5              BMI      |L1.20|
000028  040a              LSLS     r2,r1,#16             ;365
00002a  0f92              LSRS     r2,r2,#30             ;365
00002c  466b              MOV      r3,sp                 ;365
00002e  5c9b              LDRB     r3,[r3,r2]            ;365
000030  05ca              LSLS     r2,r1,#23             ;366
000032  0489              LSLS     r1,r1,#18             ;367
000034  0dd2              LSRS     r2,r2,#23             ;366
000036  0ec9              LSRS     r1,r1,#27             ;367
000038  1c89              ADDS     r1,r1,#2              ;367
00003a  0880              LSRS     r0,r0,#2              ;370
00003c  1c92              ADDS     r2,r2,#2              ;370
00003e  4359              MULS     r1,r3,r1              ;370
000040  4350              MULS     r0,r2,r0              ;370
000042  f7fffffe          BL       __aeabi_uidivmod
000046  0080              LSLS     r0,r0,#2              ;370
000048  bd08              POP      {r3,pc}
;;;374    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
00004c  01020204          DCB      1,2,2,4
                  |L1.80|
                          DCD      0x50000200
                  |L1.84|
                          DCD      0x016e3600
                  |L1.88|
                          DCD      0x00b71b00

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;39      */
;;;40     void UART_ClearIntFlag(UART_T *psUART, uint32_t u32InterruptFlag)
000000  054a              LSLS     r2,r1,#21
;;;41     {
000002  d501              BPL      |L2.8|
;;;42     
;;;43         if (u32InterruptFlag & UART_INTSTS_RLSINT_Msk)      /* Clear Receive Line Status Interrupt */
;;;44             psUART->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_ADDRDETF_Msk;
000004  2268              MOVS     r2,#0x68
000006  6182              STR      r2,[r0,#0x18]
                  |L2.8|
;;;45     
;;;46         if (u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)    /* Clear Modem Status Interrupt */
000008  050a              LSLS     r2,r1,#20
00000a  d503              BPL      |L2.20|
;;;47             psUART->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
00000c  6942              LDR      r2,[r0,#0x14]
00000e  2301              MOVS     r3,#1
000010  431a              ORRS     r2,r2,r3
000012  6142              STR      r2,[r0,#0x14]
                  |L2.20|
;;;48     
;;;49         if (u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000014  048a              LSLS     r2,r1,#18
000016  d501              BPL      |L2.28|
;;;50             psUART->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
000018  4a06              LDR      r2,|L2.52|
00001a  6182              STR      r2,[r0,#0x18]
                  |L2.28|
;;;51     
;;;52         if (u32InterruptFlag & UART_INTSTS_WKINT_Msk)       /* Clear Wake-up Interrupt */
00001c  044a              LSLS     r2,r1,#17
00001e  d501              BPL      |L2.36|
;;;53             psUART->WKSTS = psUART->WKSTS;
000020  6c42              LDR      r2,[r0,#0x44]
000022  6442              STR      r2,[r0,#0x44]
                  |L2.36|
;;;54     
;;;55         if (u32InterruptFlag & UART_INTSTS_LININT_Msk)      /* Clear LIN Bus Interrupt */
000024  0409              LSLS     r1,r1,#16
000026  d503              BPL      |L2.48|
;;;56         {
;;;57             psUART->INTSTS = UART_INTSTS_LINIF_Msk;
000028  2180              MOVS     r1,#0x80
00002a  61c1              STR      r1,[r0,#0x1c]
;;;58             psUART->LINSTS = psUART->LINSTS;
00002c  6b81              LDR      r1,[r0,#0x38]
00002e  6381              STR      r1,[r0,#0x38]
                  |L2.48|
;;;59         }
;;;60     
;;;61     }
000030  4770              BX       lr
;;;62     
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;72      */
;;;73     void UART_Close(UART_T *psUART)
000000  2100              MOVS     r1,#0
;;;74     {
;;;75         psUART->INTEN = 0;
000002  6041              STR      r1,[r0,#4]
;;;76     }
000004  4770              BX       lr
;;;77     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;87      */
;;;88     void UART_DisableFlowCtrl(UART_T *psUART)
000000  6841              LDR      r1,[r0,#4]
;;;89     {
;;;90         psUART->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;91     }
00000a  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=2

                  UART_DisableInt PROC
;;;113     */
;;;114    void UART_DisableInt(UART_T  *psUART, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;115    {
;;;116        /* Disable UART specified interrupt */
;;;117        UART_DISABLE_INT(psUART, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
000006  2001              MOVS     r0,#1
000008  4903              LDR      r1,|L5.24|
00000a  0300              LSLS     r0,r0,#12
00000c  6008              STR      r0,[r1,#0]
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
;;;118    
;;;119        /* Disable NVIC UART IRQ */
;;;120        NVIC_DisableIRQ(UART0_IRQn);
;;;121    
;;;122    }
000016  4770              BX       lr
;;;123    
                          ENDP

                  |L5.24|
                          DCD      0xe000e180

                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;132     */
;;;133    void UART_EnableFlowCtrl(UART_T *psUART)
000000  6901              LDR      r1,[r0,#0x10]
;;;134    {
;;;135        /* Set RTS pin output is low level active */
;;;136        psUART->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;137    
;;;138        /* Set CTS pin input is low level active */
;;;139        psUART->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
00000a  6941              LDR      r1,[r0,#0x14]
00000c  1052              ASRS     r2,r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6141              STR      r1,[r0,#0x14]
;;;140    
;;;141        /* Set RTS and CTS auto flow control enable */
;;;142        psUART->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000012  6841              LDR      r1,[r0,#4]
000014  2203              MOVS     r2,#3
000016  0312              LSLS     r2,r2,#12
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
;;;143    }
00001c  4770              BX       lr
;;;144    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=2

                  UART_EnableInt PROC
;;;165     */
;;;166    void UART_EnableInt(UART_T  *psUART, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;167    {
;;;168    
;;;169        /* Enable UART specified interrupt */
;;;170        UART_ENABLE_INT(psUART, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
000006  2001              MOVS     r0,#1
000008  4901              LDR      r1,|L7.16|
00000a  0300              LSLS     r0,r0,#12
00000c  6008              STR      r0,[r1,#0]
;;;171    
;;;172        /* Enable NVIC UART IRQ */
;;;173        NVIC_EnableIRQ(UART0_IRQn);
;;;174    
;;;175    }
00000e  4770              BX       lr
;;;176    
                          ENDP

                  |L7.16|
                          DCD      0xe000e100

                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;187     */
;;;188    void UART_Open(UART_T *psUART, uint32_t u32Baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;189    {
000002  4604              MOV      r4,r0
;;;190        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;191        uint32_t au32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC_DIV2};
000004  481c              LDR      r0,|L8.120|
000006  460d              MOV      r5,r1                 ;189
000008  c80f              LDM      r0,{r0-r3}
00000a  b085              SUB      sp,sp,#0x14           ;189
00000c  466e              MOV      r6,sp
00000e  c60f              STM      r6!,{r0-r3}
;;;192        uint32_t u32BaudDiv = 0;
;;;193    
;;;194        /* Get UART clock source selection */
;;;195        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000010  481a              LDR      r0,|L8.124|
000012  6941              LDR      r1,[r0,#0x14]
;;;196    
;;;197        /* Get UART clock divider number */
;;;198        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000014  6980              LDR      r0,[r0,#0x18]
;;;199    
;;;200        /* Select UART function */
;;;201        psUART->FUNCSEL = UART_FUNCSEL_UART;
;;;202    
;;;203        /* Set UART line configuration */
;;;204        psUART->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
;;;205    
;;;206        /* Set UART Rx and RTS trigger level */
;;;207        psUART->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
;;;208    
;;;209        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;210        if (u8UartClkSrcSel == 1)
;;;211            au32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;212    
;;;213        /* Set UART baud rate */
;;;214        if (u32Baudrate != 0)
;;;215        {
;;;216            u32BaudDiv = UART_BAUD_MODE2_DIVIDER((au32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Baudrate);
;;;217    
;;;218            if (u32BaudDiv > 0xFFFF)
;;;219                psUART->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((au32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Baudrate));
;;;220            else
;;;221                psUART->BAUD = (UART_BAUD_MODE2 | u32BaudDiv);
;;;222        }
;;;223    }
000016  018a              LSLS     r2,r1,#6
000018  2103              MOVS     r1,#3
00001a  0f96              LSRS     r6,r2,#30
00001c  0500              LSLS     r0,r0,#20
00001e  0f07              LSRS     r7,r0,#28
000020  2000              MOVS     r0,#0                 ;201
000022  6320              STR      r0,[r4,#0x30]         ;201
000024  60e1              STR      r1,[r4,#0xc]          ;204
000026  68a0              LDR      r0,[r4,#8]            ;207
000028  4915              LDR      r1,|L8.128|
00002a  4008              ANDS     r0,r0,r1              ;207
00002c  60a0              STR      r0,[r4,#8]            ;207
00002e  2e01              CMP      r6,#1                 ;210
000030  d102              BNE      |L8.56|
000032  f7fffffe          BL       CLK_GetPLLClockFreq
000036  9001              STR      r0,[sp,#4]            ;211
                  |L8.56|
000038  2d00              CMP      r5,#0                 ;214
00003a  d01b              BEQ      |L8.116|
00003c  00b1              LSLS     r1,r6,#2              ;216
00003e  4668              MOV      r0,sp                 ;216
000040  5840              LDR      r0,[r0,r1]            ;216
000042  1c79              ADDS     r1,r7,#1              ;216
000044  f7fffffe          BL       __aeabi_uidivmod
000048  4606              MOV      r6,r0                 ;216
00004a  0869              LSRS     r1,r5,#1              ;216
00004c  1840              ADDS     r0,r0,r1              ;216
00004e  4629              MOV      r1,r5                 ;216
000050  f7fffffe          BL       __aeabi_uidivmod
000054  490b              LDR      r1,|L8.132|
000056  1e80              SUBS     r0,r0,#2              ;218
000058  4288              CMP      r0,r1                 ;218
00005a  d907              BLS      |L8.108|
00005c  00e9              LSLS     r1,r5,#3              ;219
00005e  1870              ADDS     r0,r6,r1              ;219
000060  4629              MOV      r1,r5                 ;219
000062  f7fffffe          BL       __aeabi_uidivmod
000066  0900              LSRS     r0,r0,#4              ;219
000068  1e80              SUBS     r0,r0,#2              ;219
00006a  e002              B        |L8.114|
                  |L8.108|
00006c  2103              MOVS     r1,#3                 ;221
00006e  0709              LSLS     r1,r1,#28             ;221
000070  4308              ORRS     r0,r0,r1              ;221
                  |L8.114|
000072  6260              STR      r0,[r4,#0x24]         ;221
                  |L8.116|
000074  b005              ADD      sp,sp,#0x14
000076  bdf0              POP      {r4-r7,pc}
;;;224    
                          ENDP

                  |L8.120|
                          DCD      ||.constdata||
                  |L8.124|
                          DCD      0x50000200
                  |L8.128|
                          DCD      0xfff0ff0f
                  |L8.132|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;236     */
;;;237    uint32_t UART_Read(UART_T *psUART, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;238    {
000002  4604              MOV      r4,r0
;;;239        uint32_t  u32Count, u32Delayno;
;;;240    
;;;241        for (u32Count = 0; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;242        {
;;;243            u32Delayno = 0;
;;;244    
;;;245            while (psUART->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;246            {
;;;247                u32Delayno++;
;;;248    
;;;249                if (u32Delayno >= 0x40000000)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L9.38|
                  |L9.12|
00000c  2300              MOVS     r3,#0                 ;243
00000e  e004              B        |L9.26|
                  |L9.16|
000010  1c5b              ADDS     r3,r3,#1              ;245
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L9.26|
;;;250                    return FALSE;
000016  2000              MOVS     r0,#0
;;;251            }
;;;252    
;;;253            pu8RxBuf[u32Count] = psUART->DAT;    /* Get Data from UART RX  */
;;;254        }
;;;255    
;;;256        return u32Count;
;;;257    
;;;258    }
000018  bd70              POP      {r4-r6,pc}
                  |L9.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;245
00001c  0476              LSLS     r6,r6,#17             ;245
00001e  d4f7              BMI      |L9.16|
000020  6823              LDR      r3,[r4,#0]            ;253
000022  540b              STRB     r3,[r1,r0]            ;253
000024  1c40              ADDS     r0,r0,#1              ;253
                  |L9.38|
000026  4290              CMP      r0,r2                 ;241
000028  d3f0              BCC      |L9.12|
00002a  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;351     */
;;;352    void UART_SelectIrDAMode(UART_T *psUART, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;353    {
000002  4604              MOV      r4,r0
;;;354        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;355        uint32_t au32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC_DIV2};
000004  481c              LDR      r0,|L10.120|
000006  b084              SUB      sp,sp,#0x10           ;353
000008  c80f              LDM      r0,{r0-r3}
;;;356        uint32_t u32Baud_Div;
;;;357    
;;;358        /* Select IrDA function mode */
;;;359        psUART->FUNCSEL = UART_FUNCSEL_IrDA;
00000a  466d              MOV      r5,sp
00000c  c50f              STM      r5!,{r0-r3}
00000e  2602              MOVS     r6,#2
000010  6326              STR      r6,[r4,#0x30]
;;;360    
;;;361        /* Get UART clock source selection */
;;;362        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000012  481a              LDR      r0,|L10.124|
000014  6941              LDR      r1,[r0,#0x14]
;;;363    
;;;364        /* Get UART clock divider number */
;;;365        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000016  6980              LDR      r0,[r0,#0x18]
;;;366    
;;;367        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;368        if (u8UartClkSrcSel == 1)
;;;369            au32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;370    
;;;371        /* Set UART IrDA baud rate in mode 0 */
;;;372        if (u32Buadrate != 0)
;;;373        {
;;;374            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((au32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Buadrate);
;;;375    
;;;376            if (u32Baud_Div < 0xFFFF)
;;;377                psUART->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;378        }
;;;379    
;;;380        /* Configure IrDA relative settings */
;;;381        if (u32Direction == UART_IRDA_RXEN)
;;;382        {
;;;383            psUART->IRDA |= UART_IRDA_RXINV_Msk;     //Rx signal is inverse
;;;384            psUART->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;385        }
;;;386        else
;;;387        {
;;;388            psUART->IRDA &= ~UART_IRDA_TXINV_Msk;    //Tx signal is not inverse
;;;389            psUART->IRDA |= UART_IRDA_TXEN_Msk;
;;;390        }
;;;391    
;;;392    }
000018  0189              LSLS     r1,r1,#6
00001a  0f8d              LSRS     r5,r1,#30
00001c  0500              LSLS     r0,r0,#20
00001e  0f07              LSRS     r7,r0,#28
000020  2d01              CMP      r5,#1                 ;368
000022  d102              BNE      |L10.42|
000024  f7fffffe          BL       CLK_GetPLLClockFreq
000028  9001              STR      r0,[sp,#4]            ;369
                  |L10.42|
00002a  9805              LDR      r0,[sp,#0x14]         ;372
00002c  2800              CMP      r0,#0                 ;372
00002e  d011              BEQ      |L10.84|
000030  00a9              LSLS     r1,r5,#2              ;374
000032  4668              MOV      r0,sp                 ;374
000034  5840              LDR      r0,[r0,r1]            ;374
000036  1c79              ADDS     r1,r7,#1              ;374
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  9905              LDR      r1,[sp,#0x14]         ;374
00003e  00c9              LSLS     r1,r1,#3              ;374
000040  1840              ADDS     r0,r0,r1              ;374
000042  9905              LDR      r1,[sp,#0x14]         ;374
000044  f7fffffe          BL       __aeabi_uidivmod
000048  0900              LSRS     r0,r0,#4              ;374
00004a  490d              LDR      r1,|L10.128|
00004c  1e80              SUBS     r0,r0,#2              ;376
00004e  4288              CMP      r0,r1                 ;376
000050  d200              BCS      |L10.84|
000052  6260              STR      r0,[r4,#0x24]         ;377
                  |L10.84|
000054  9806              LDR      r0,[sp,#0x18]         ;381
000056  2800              CMP      r0,#0                 ;381
000058  6aa0              LDR      r0,[r4,#0x28]         ;388
00005a  d007              BEQ      |L10.108|
00005c  2120              MOVS     r1,#0x20              ;388
00005e  4388              BICS     r0,r0,r1              ;388
000060  62a0              STR      r0,[r4,#0x28]         ;388
000062  6aa0              LDR      r0,[r4,#0x28]         ;389
000064  4330              ORRS     r0,r0,r6              ;389
                  |L10.102|
000066  62a0              STR      r0,[r4,#0x28]         ;384
000068  b007              ADD      sp,sp,#0x1c
00006a  bdf0              POP      {r4-r7,pc}
                  |L10.108|
00006c  2140              MOVS     r1,#0x40              ;383
00006e  4308              ORRS     r0,r0,r1              ;383
000070  62a0              STR      r0,[r4,#0x28]         ;383
000072  6aa0              LDR      r0,[r4,#0x28]         ;384
000074  43b0              BICS     r0,r0,r6              ;384
000076  e7f6              B        |L10.102|
;;;393    
                          ENDP

                  |L10.120|
                          DCD      ||.constdata||+0x20
                  |L10.124|
                          DCD      0x50000200
                  |L10.128|
                          DCD      0x0000ffff

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;432     */
;;;433    void UART_SelectLINMode(UART_T *psUART, uint32_t u32Mode, uint32_t u32BreakLength)
000000  b510              PUSH     {r4,lr}
;;;434    {
;;;435        /* Select LIN function mode */
;;;436        psUART->FUNCSEL = UART_FUNCSEL_LIN;
000002  2301              MOVS     r3,#1
000004  6303              STR      r3,[r0,#0x30]
;;;437    
;;;438        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;439        psUART->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  24cf              MOVS     r4,#0xcf
00000a  43a3              BICS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;440        psUART->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  4311              ORRS     r1,r1,r2
000012  430b              ORRS     r3,r3,r1
000014  62c3              STR      r3,[r0,#0x2c]
;;;441    }
000016  bd10              POP      {r4,pc}
;;;442    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;408     */
;;;409    void UART_SelectRS485Mode(UART_T *psUART, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;410    {
;;;411        /* Select UART RS485 function mode */
;;;412        psUART->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;413    
;;;414        /* Set RS585 configuration */
;;;415        psUART->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L12.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;416        psUART->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  0612              LSLS     r2,r2,#24
000012  430a              ORRS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  62c3              STR      r3,[r0,#0x2c]
;;;417    }
000018  bd10              POP      {r4,pc}
;;;418    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;286     */
;;;287    void UART_SetLine_Config(UART_T *psUART, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;288    {
000002  4605              MOV      r5,r0
;;;289        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;290        uint32_t au32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC_DIV2};
000004  481b              LDR      r0,|L13.116|
000006  460c              MOV      r4,r1                 ;288
000008  c80f              LDM      r0,{r0-r3}
00000a  b085              SUB      sp,sp,#0x14           ;288
00000c  466e              MOV      r6,sp
00000e  c60f              STM      r6!,{r0-r3}
;;;291        uint32_t u32Baud_Div = 0;
;;;292    
;;;293        /* Get UART clock source selection */
;;;294        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000010  4819              LDR      r0,|L13.120|
000012  6941              LDR      r1,[r0,#0x14]
;;;295    
;;;296        /* Get UART clock divider number */
;;;297        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000014  6980              LDR      r0,[r0,#0x18]
;;;298    
;;;299        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;300        if (u8UartClkSrcSel == 1)
;;;301            au32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;302    
;;;303        /* Set UART baud rate */
;;;304        if (u32Baudrate != 0)
;;;305        {
;;;306            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((au32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Baudrate);
;;;307    
;;;308            if (u32Baud_Div > 0xFFFF)
;;;309                psUART->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((au32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Baudrate));
;;;310            else
;;;311                psUART->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;312        }
;;;313    
;;;314        /* Set UART line configuration */
;;;315        psUART->LINE = u32DataWidth | u32Parity | u32StopBits;
;;;316    }
000016  0189              LSLS     r1,r1,#6
000018  0f8e              LSRS     r6,r1,#30
00001a  0500              LSLS     r0,r0,#20
00001c  0f07              LSRS     r7,r0,#28
00001e  2e01              CMP      r6,#1                 ;300
000020  d102              BNE      |L13.40|
000022  f7fffffe          BL       CLK_GetPLLClockFreq
000026  9001              STR      r0,[sp,#4]            ;301
                  |L13.40|
000028  2c00              CMP      r4,#0                 ;304
00002a  d01b              BEQ      |L13.100|
00002c  00b1              LSLS     r1,r6,#2              ;306
00002e  4668              MOV      r0,sp                 ;306
000030  5840              LDR      r0,[r0,r1]            ;306
000032  1c79              ADDS     r1,r7,#1              ;306
000034  f7fffffe          BL       __aeabi_uidivmod
000038  4606              MOV      r6,r0                 ;306
00003a  0861              LSRS     r1,r4,#1              ;306
00003c  1840              ADDS     r0,r0,r1              ;306
00003e  4621              MOV      r1,r4                 ;306
000040  f7fffffe          BL       __aeabi_uidivmod
000044  490d              LDR      r1,|L13.124|
000046  1e80              SUBS     r0,r0,#2              ;308
000048  4288              CMP      r0,r1                 ;308
00004a  d907              BLS      |L13.92|
00004c  00e1              LSLS     r1,r4,#3              ;309
00004e  1870              ADDS     r0,r6,r1              ;309
000050  4621              MOV      r1,r4                 ;309
000052  f7fffffe          BL       __aeabi_uidivmod
000056  0900              LSRS     r0,r0,#4              ;309
000058  1e80              SUBS     r0,r0,#2              ;309
00005a  e002              B        |L13.98|
                  |L13.92|
00005c  2103              MOVS     r1,#3                 ;311
00005e  0709              LSLS     r1,r1,#28             ;311
000060  4308              ORRS     r0,r0,r1              ;311
                  |L13.98|
000062  6268              STR      r0,[r5,#0x24]         ;309
                  |L13.100|
000064  9908              LDR      r1,[sp,#0x20]         ;315
000066  9807              LDR      r0,[sp,#0x1c]         ;315
000068  4308              ORRS     r0,r0,r1              ;315
00006a  990e              LDR      r1,[sp,#0x38]         ;315
00006c  4308              ORRS     r0,r0,r1              ;315
00006e  60e8              STR      r0,[r5,#0xc]          ;315
000070  b009              ADD      sp,sp,#0x24
000072  bdf0              POP      {r4-r7,pc}
;;;317    
                          ENDP

                  |L13.116|
                          DCD      ||.constdata||+0x10
                  |L13.120|
                          DCD      0x50000200
                  |L13.124|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;328     */
;;;329    void UART_SetTimeoutCnt(UART_T *psUART, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;330    {
;;;331        /* Set time-out interrupt comparator */
;;;332        psUART->TOUT = (psUART->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;333    
;;;334        /* Set time-out counter enable */
;;;335        psUART->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  2201              MOVS     r2,#1
00000e  02d2              LSLS     r2,r2,#11
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;336    }
000014  4770              BX       lr
;;;337    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;454     */
;;;455    uint32_t UART_Write(UART_T *psUART, uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;456    {
000002  4604              MOV      r4,r0
;;;457        uint32_t  u32Count, u32Delayno;
;;;458    
;;;459        for (u32Count = 0; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;460        {
;;;461            u32Delayno = 0;
;;;462    
;;;463            while (psUART->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)  /* Check Tx Full */
;;;464            {
;;;465                u32Delayno++;
;;;466    
;;;467                if (u32Delayno >= 0x40000000)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L15.38|
                  |L15.12|
00000c  2300              MOVS     r3,#0                 ;461
00000e  e004              B        |L15.26|
                  |L15.16|
000010  1c5b              ADDS     r3,r3,#1              ;463
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L15.26|
;;;468                    return FALSE;
000016  2000              MOVS     r0,#0
;;;469            }
;;;470    
;;;471            psUART->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;472        }
;;;473    
;;;474        return u32Count;
;;;475    
;;;476    }
000018  bd70              POP      {r4-r6,pc}
                  |L15.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;463
00001c  0236              LSLS     r6,r6,#8              ;463
00001e  d4f7              BMI      |L15.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;471
000022  6023              STR      r3,[r4,#0]            ;471
000024  1c40              ADDS     r0,r0,#1              ;471
                  |L15.38|
000026  4290              CMP      r0,r2                 ;459
000028  d1f0              BNE      |L15.12|
00002a  bd70              POP      {r4-r6,pc}
;;;477    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x016e3600
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x016e3600
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x016e3600

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 479
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
