; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.I2C0_Close||, CODE, READONLY, ALIGN=2

                  I2C0_Close PROC
;;;723    
;;;724    void I2C0_Close(void)
000000  b510              PUSH     {r4,lr}
;;;725    {
;;;726        /* Disable I2C0 interrupt and clear corresponding NVIC bit */
;;;727        I2C_DisableInt(I2C0);
000002  4c07              LDR      r4,|L1.32|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_DisableInt
;;;728        NVIC_DisableIRQ(I2C0_IRQn);
00000a  2012              MOVS     r0,#0x12
00000c  f7fffffe          BL       __NVIC_DisableIRQ
;;;729    
;;;730        /* Disable I2C0 and close I2C0 clock */
;;;731        I2C_Close(I2C0);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2C_Close
;;;732        CLK_DisableModuleClock(I2C0_MODULE);
000016  4803              LDR      r0,|L1.36|
000018  f7fffffe          BL       CLK_DisableModuleClock
;;;733    
;;;734    }
00001c  bd10              POP      {r4,pc}
;;;735    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x40020000
                  |L1.36|
                          DCD      0x40000008

                          AREA ||i.I2C0_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C0_IRQHandler PROC
;;;109    /*---------------------------------------------------------------------------------------------------------*/
;;;110    void I2C0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;111    {
;;;112        uint32_t u32Status;
;;;113    
;;;114        u32Status = I2C_GET_STATUS(I2C0);
000002  4908              LDR      r1,|L2.36|
000004  68c8              LDR      r0,[r1,#0xc]
;;;115    
;;;116        if(I2C_GET_TIMEOUT_FLAG(I2C0))
000006  694a              LDR      r2,[r1,#0x14]
000008  43d2              MVNS     r2,r2
00000a  07d2              LSLS     r2,r2,#31
00000c  d006              BEQ      |L2.28|
;;;117        {
;;;118            /* Clear I2C0 Timeout Flag */
;;;119            I2C_ClearTimeoutFlag(I2C0);
;;;120        }
;;;121        else
;;;122        {
;;;123            if(s_I2C0HandlerFn != NULL)
00000e  4906              LDR      r1,|L2.40|
000010  68ca              LDR      r2,[r1,#0xc]  ; s_I2C0HandlerFn
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L2.26|
;;;124                s_I2C0HandlerFn(u32Status);
000016  68c9              LDR      r1,[r1,#0xc]  ; s_I2C0HandlerFn
000018  4788              BLX      r1
                  |L2.26|
;;;125        }
;;;126    }
00001a  bd10              POP      {r4,pc}
                  |L2.28|
00001c  4608              MOV      r0,r1                 ;119
00001e  f7fffffe          BL       I2C_ClearTimeoutFlag
000022  bd10              POP      {r4,pc}
;;;127    
                          ENDP

                  |L2.36|
                          DCD      0x40020000
                  |L2.40|
                          DCD      ||.data||

                          AREA ||i.I2C0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C0_Init PROC
;;;642    }
;;;643    void I2C0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;644    {
;;;645    	#if defined (ENABLE_NUC125)
;;;646        SYS_ResetModule(I2C0_RST);
000002  4821              LDR      r0,|L3.136|
000004  f7fffffe          BL       SYS_ResetModule
;;;647    	#endif
;;;648    
;;;649        /* Open I2C0 module and set bus clock */
;;;650        I2C_Open(I2C0, 100000);
000008  4c21              LDR      r4,|L3.144|
00000a  4920              LDR      r1,|L3.140|
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_Open
;;;651    
;;;652        /* Get I2C0 Bus Clock */
;;;653        printf("I2C0 clock %d Hz\n", I2C_GetBusClockFreq(I2C0));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       I2C_GetBusClockFreq
000018  4601              MOV      r1,r0
00001a  a01e              ADR      r0,|L3.148|
00001c  f7fffffe          BL       __2printf
;;;654    
;;;655        /* Set I2C0 4 Slave Addresses */
;;;656        I2C_SetSlaveAddr(I2C0, 0, 0x15, 0);   /* Slave Address : 0x15 */
000020  2300              MOVS     r3,#0
000022  2215              MOVS     r2,#0x15
000024  4619              MOV      r1,r3
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       I2C_SetSlaveAddr
;;;657        I2C_SetSlaveAddr(I2C0, 1, 0x35, 0);   /* Slave Address : 0x35 */
00002c  2300              MOVS     r3,#0
00002e  2235              MOVS     r2,#0x35
000030  2101              MOVS     r1,#1
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       I2C_SetSlaveAddr
;;;658        I2C_SetSlaveAddr(I2C0, 2, 0x55, 0);   /* Slave Address : 0x55 */
000038  2300              MOVS     r3,#0
00003a  2255              MOVS     r2,#0x55
00003c  2102              MOVS     r1,#2
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       I2C_SetSlaveAddr
;;;659        I2C_SetSlaveAddr(I2C0, 3, 0x75, 0);   /* Slave Address : 0x75 */
000044  2300              MOVS     r3,#0
000046  2275              MOVS     r2,#0x75
000048  2103              MOVS     r1,#3
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_SetSlaveAddr
;;;660    
;;;661        /* Set I2C0 4 Slave Addresses Mask */
;;;662        I2C_SetSlaveAddrMask(I2C0, 0, 0x01);
000050  2201              MOVS     r2,#1
000052  2100              MOVS     r1,#0
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;663        I2C_SetSlaveAddrMask(I2C0, 1, 0x04);
00005a  2204              MOVS     r2,#4
00005c  2101              MOVS     r1,#1
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;664        I2C_SetSlaveAddrMask(I2C0, 2, 0x01);
000064  2201              MOVS     r2,#1
000066  2102              MOVS     r1,#2
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;665        I2C_SetSlaveAddrMask(I2C0, 3, 0x04);
00006e  2204              MOVS     r2,#4
000070  2103              MOVS     r1,#3
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;666    
;;;667        /* Enable I2C0 interrupt */
;;;668        I2C_EnableInt(I2C0);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       I2C_EnableInt
;;;669        NVIC_EnableIRQ(I2C0_IRQn);
00007e  2012              MOVS     r0,#0x12
000080  f7fffffe          BL       __NVIC_EnableIRQ
;;;670    }
000084  bd10              POP      {r4,pc}
;;;671    
                          ENDP

000086  0000              DCW      0x0000
                  |L3.136|
                          DCD      0x04000008
                  |L3.140|
                          DCD      0x000186a0
                  |L3.144|
                          DCD      0x40020000
                  |L3.148|
000094  49324330          DCB      "I2C0 clock %d Hz\n",0
000098  20636c6f
00009c  636b2025
0000a0  6420487a
0000a4  0a00    
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.I2C0_Read_Write_Slave||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  I2C0_Read_Write_Slave PROC
;;;746    
;;;747    int32_t I2C0_Read_Write_Slave(uint8_t slvaddr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;748    {
;;;749    #if 1
;;;750        uint32_t u32Index;
;;;751    	
;;;752        g_u8DeviceAddr = slvaddr;
000002  4d1e              LDR      r5,|L4.124|
000004  4606              MOV      r6,r0                 ;748
000006  7268              STRB     r0,[r5,#9]
;;;753    
;;;754        printf("Dump transmitted data:\r\n");
000008  a01d              ADR      r0,|L4.128|
00000a  f7fffffe          BL       __2printf
;;;755    
;;;756        for (u32Index = 0; u32Index < I2C_DATA_MAX; u32Index++)
;;;757        {
;;;758            g_au8MstTxData[u32Index] = g_u8test_data + u32Index;
00000e  4f23              LDR      r7,|L4.156|
000010  2400              MOVS     r4,#0                 ;756
                  |L4.18|
000012  78a8              LDRB     r0,[r5,#2]  ; g_u8test_data
000014  1900              ADDS     r0,r0,r4
000016  5538              STRB     r0,[r7,r4]
;;;759            printf("0x%2X , ", g_au8MstTxData[u32Index]);
000018  5d39              LDRB     r1,[r7,r4]
00001a  a021              ADR      r0,|L4.160|
00001c  f7fffffe          BL       __2printf
;;;760    		
;;;761            if ((u32Index+1)%8 ==0)
000020  2001              MOVS     r0,#1
000022  0761              LSLS     r1,r4,#29
000024  0740              LSLS     r0,r0,#29
000026  42c1              CMN      r1,r0
000028  d102              BNE      |L4.48|
;;;762            {
;;;763                printf("\r\n");
00002a  a020              ADR      r0,|L4.172|
00002c  f7fffffe          BL       __2printf
                  |L4.48|
000030  1c64              ADDS     r4,r4,#1
000032  2c18              CMP      r4,#0x18              ;756
000034  d3ed              BCC      |L4.18|
;;;764            }
;;;765    		
;;;766        }
;;;767    
;;;768    	printf("\r\n");
000036  a01d              ADR      r0,|L4.172|
000038  f7fffffe          BL       __2printf
;;;769    
;;;770        g_u8MonDataCnt = 0;
00003c  2100              MOVS     r1,#0
00003e  7069              STRB     r1,[r5,#1]
;;;771        g_u8MstDataLen = 0;
000040  72a9              STRB     r1,[r5,#0xa]
;;;772        g_u8MstEndFlag = 0;
000042  7029              STRB     r1,[r5,#0]
;;;773    
;;;774        /* I2C function to write data to slave */
;;;775        s_I2C0HandlerFn = (I2C_FUNC)I2C_MasterTx;
000044  481a              LDR      r0,|L4.176|
000046  60e8              STR      r0,[r5,#0xc]  ; s_I2C0HandlerFn
;;;776    
;;;777        /* I2C as master sends START signal */
;;;778        I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
000048  4a1a              LDR      r2,|L4.180|
00004a  6810              LDR      r0,[r2,#0]
00004c  233c              MOVS     r3,#0x3c
00004e  4398              BICS     r0,r0,r3
000050  3020              ADDS     r0,r0,#0x20
000052  6010              STR      r0,[r2,#0]
                  |L4.84|
;;;779    
;;;780        /* Wait I2C Tx Finish */
;;;781        while (g_u8MstEndFlag == 0);
000054  7828              LDRB     r0,[r5,#0]  ; g_u8MstEndFlag
000056  2800              CMP      r0,#0
000058  d0fc              BEQ      |L4.84|
;;;782    
;;;783        g_u8MstEndFlag = 0;
00005a  7029              STRB     r1,[r5,#0]
;;;784    
;;;785        /* I2C function to read data from slave */
;;;786        s_I2C0HandlerFn = (I2C_FUNC)I2C_MasterRx;
00005c  4816              LDR      r0,|L4.184|
00005e  60e8              STR      r0,[r5,#0xc]  ; s_I2C0HandlerFn
;;;787    
;;;788        g_u8MstDataLen = 0;
000060  72a9              STRB     r1,[r5,#0xa]
;;;789        g_u8DeviceAddr = slvaddr;
000062  726e              STRB     r6,[r5,#9]
;;;790    
;;;791        I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
000064  6810              LDR      r0,[r2,#0]
000066  4398              BICS     r0,r0,r3
000068  3020              ADDS     r0,r0,#0x20
00006a  6010              STR      r0,[r2,#0]
                  |L4.108|
;;;792    
;;;793        /* Wait I2C Rx Finish */
;;;794        while (g_u8MstEndFlag == 0);
00006c  7828              LDRB     r0,[r5,#0]  ; g_u8MstEndFlag
00006e  2800              CMP      r0,#0
000070  d0fc              BEQ      |L4.108|
                  |L4.114|
;;;795    
;;;796        /* Compare data */
;;;797    //    if(g_u8MstRxData != g_au8MstTxData[2])
;;;798    //    {
;;;799    //        printf("I2C0 Byte Write/Read Failed, Data 0x%x\r\n", g_u8MstRxData);
;;;800    //        while(1);
;;;801    //    }
;;;802    
;;;803        while (g_u32ProtOn);
000072  69a8              LDR      r0,[r5,#0x18]  ; g_u32ProtOn
000074  2800              CMP      r0,#0
000076  d1fc              BNE      |L4.114|
;;;804    
;;;805        return 0;
;;;806    #else
;;;807    
;;;808    
;;;809        uint32_t i;
;;;810    
;;;811        g_u8DeviceAddr = slvaddr;
;;;812    
;;;813        for(i = 0; i < MONITOR_TEST_CNT; i++)
;;;814        {
;;;815            g_au8MstTxData[0] = (uint8_t)((i & 0xFF00) >> 8);
;;;816            g_au8MstTxData[1] = (uint8_t)(i & 0x00FF);
;;;817            g_au8MstTxData[2] = (uint8_t)(g_au8MstTxData[1] + 3);
;;;818    
;;;819            g_u8MstDataLen = 0;
;;;820            g_u8MstEndFlag = 0;
;;;821    
;;;822            /* I2C0 function to write data to slave */
;;;823            s_I2C0HandlerFn = (I2C_FUNC)I2C_MasterTx;
;;;824    
;;;825            /* I2C0 as master sends START signal */
;;;826            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
;;;827    
;;;828            /* Wait I2C0 Tx Finish */
;;;829            while(g_u8MstEndFlag == 0);
;;;830            g_u8MstEndFlag = 0;
;;;831    
;;;832            /* I2C0 function to read data from slave */
;;;833            s_I2C0HandlerFn = (I2C_FUNC)I2C_MasterRx;
;;;834    
;;;835            g_u8MstDataLen = 0;
;;;836            g_u8DeviceAddr = slvaddr;
;;;837    
;;;838            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
;;;839    
;;;840            /* Wait I2C0 Rx Finish */
;;;841            while(g_u8MstEndFlag == 0);
;;;842    
;;;843            /* Compare data */
;;;844            if(g_u8MstRxData != g_au8MstTxData[2])
;;;845            {
;;;846                printf("I2C0 Byte Write/Read Failed, Data 0x%x\n", g_u8MstRxData);
;;;847                while(1);
;;;848            }
;;;849        }
;;;850        printf("Master Access Slave (0x%X) Test OK\n", slvaddr);
;;;851        return 0;
;;;852    #endif	
;;;853    }
000078  bdf8              POP      {r3-r7,pc}
;;;854    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      ||.data||
                  |L4.128|
000080  44756d70          DCB      "Dump transmitted data:\r\n",0
000084  20747261
000088  6e736d69
00008c  74746564
000090  20646174
000094  613a0d0a
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L4.156|
                          DCD      ||.bss||+0x62
                  |L4.160|
0000a0  30782532          DCB      "0x%2X , ",0
0000a4  58202c20
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L4.172|
0000ac  0d0a00            DCB      "\r\n",0
0000af  00                DCB      0
                  |L4.176|
                          DCD      I2C_MasterTx
                  |L4.180|
                          DCD      0x40020000
                  |L4.184|
                          DCD      I2C_MasterRx

                          AREA ||i.I2C1_Close||, CODE, READONLY, ALIGN=2

                  I2C1_Close PROC
;;;735    
;;;736    void I2C1_Close(void)
000000  b510              PUSH     {r4,lr}
;;;737    {
;;;738        /* Disable I2C1 interrupt and clear corresponding NVIC bit */
;;;739        I2C_DisableInt(I2C1);
000002  4c07              LDR      r4,|L5.32|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_DisableInt
;;;740        NVIC_DisableIRQ(I2C1_IRQn);
00000a  2013              MOVS     r0,#0x13
00000c  f7fffffe          BL       __NVIC_DisableIRQ
;;;741    
;;;742        /* Disable I2C1 and close I2C1 clock */
;;;743        I2C_Close(I2C1);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2C_Close
;;;744        CLK_DisableModuleClock(I2C1_MODULE);
000016  4803              LDR      r0,|L5.36|
000018  f7fffffe          BL       CLK_DisableModuleClock
;;;745    }
00001c  bd10              POP      {r4,pc}
;;;746    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      0x40120000
                  |L5.36|
                          DCD      0x40000009

                          AREA ||i.I2C1_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C1_IRQHandler PROC
;;;130    /*---------------------------------------------------------------------------------------------------------*/
;;;131    void I2C1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;132    {
;;;133        uint32_t u32Status;
;;;134    
;;;135        u32Status = I2C_GET_STATUS(I2C1);
000002  4908              LDR      r1,|L6.36|
000004  68c8              LDR      r0,[r1,#0xc]
;;;136    
;;;137        if(I2C_GET_TIMEOUT_FLAG(I2C1))
000006  694a              LDR      r2,[r1,#0x14]
000008  43d2              MVNS     r2,r2
00000a  07d2              LSLS     r2,r2,#31
00000c  d006              BEQ      |L6.28|
;;;138        {
;;;139            /* Clear I2C1 Timeout Flag */
;;;140            I2C_ClearTimeoutFlag(I2C1);
;;;141        }
;;;142        else
;;;143        {
;;;144            if(s_I2C1HandlerFn != NULL)
00000e  4906              LDR      r1,|L6.40|
000010  690a              LDR      r2,[r1,#0x10]  ; s_I2C1HandlerFn
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L6.26|
;;;145                s_I2C1HandlerFn(u32Status);
000016  6909              LDR      r1,[r1,#0x10]  ; s_I2C1HandlerFn
000018  4788              BLX      r1
                  |L6.26|
;;;146        }
;;;147    }
00001a  bd10              POP      {r4,pc}
                  |L6.28|
00001c  4608              MOV      r0,r1                 ;140
00001e  f7fffffe          BL       I2C_ClearTimeoutFlag
000022  bd10              POP      {r4,pc}
;;;148    
                          ENDP

                  |L6.36|
                          DCD      0x40120000
                  |L6.40|
                          DCD      ||.data||

                          AREA ||i.I2C1_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C1_Init PROC
;;;671    
;;;672    void I2C1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;673    {
;;;674    	#if defined (ENABLE_NUC125)
;;;675        /* Reset I2C1 */
;;;676        SYS_ResetModule(I2C1_RST);
000002  4821              LDR      r0,|L7.136|
000004  f7fffffe          BL       SYS_ResetModule
;;;677    	#endif
;;;678    
;;;679        /* Open I2C1 module and set bus clock */
;;;680        I2C_Open(I2C1, 100000);
000008  4c21              LDR      r4,|L7.144|
00000a  4920              LDR      r1,|L7.140|
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_Open
;;;681    
;;;682        /* Get I2C1 Bus Clock */
;;;683        printf("I2C1 clock %d Hz\n", I2C_GetBusClockFreq(I2C1));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       I2C_GetBusClockFreq
000018  4601              MOV      r1,r0
00001a  a01e              ADR      r0,|L7.148|
00001c  f7fffffe          BL       __2printf
;;;684    
;;;685        /* Set I2C1 4 Slave Addresses */
;;;686        I2C_SetSlaveAddr(I2C1, 0, 0x16, 0);   /* Slave Address : 0x16 */
000020  2300              MOVS     r3,#0
000022  2216              MOVS     r2,#0x16
000024  4619              MOV      r1,r3
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       I2C_SetSlaveAddr
;;;687        I2C_SetSlaveAddr(I2C1, 1, 0x36, 0);   /* Slave Address : 0x36 */
00002c  2300              MOVS     r3,#0
00002e  2236              MOVS     r2,#0x36
000030  2101              MOVS     r1,#1
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       I2C_SetSlaveAddr
;;;688        I2C_SetSlaveAddr(I2C1, 2, 0x56, 0);   /* Slave Address : 0x56 */
000038  2300              MOVS     r3,#0
00003a  2256              MOVS     r2,#0x56
00003c  2102              MOVS     r1,#2
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       I2C_SetSlaveAddr
;;;689        I2C_SetSlaveAddr(I2C1, 3, 0x76, 0);   /* Slave Address : 0x76 */
000044  2300              MOVS     r3,#0
000046  2276              MOVS     r2,#0x76
000048  2103              MOVS     r1,#3
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_SetSlaveAddr
;;;690    
;;;691        /* Set I2C1 4 Slave Addresses Mask */
;;;692        I2C_SetSlaveAddrMask(I2C1, 0, 0x04);
000050  2204              MOVS     r2,#4
000052  2100              MOVS     r1,#0
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;693        I2C_SetSlaveAddrMask(I2C1, 1, 0x02);
00005a  2202              MOVS     r2,#2
00005c  2101              MOVS     r1,#1
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;694        I2C_SetSlaveAddrMask(I2C1, 2, 0x04);
000064  2204              MOVS     r2,#4
000066  2102              MOVS     r1,#2
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;695        I2C_SetSlaveAddrMask(I2C1, 3, 0x02);
00006e  2202              MOVS     r2,#2
000070  2103              MOVS     r1,#3
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       I2C_SetSlaveAddrMask
;;;696    
;;;697        /* Enable I2C interrupt */
;;;698        I2C_EnableInt(I2C1);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       I2C_EnableInt
;;;699        NVIC_EnableIRQ(I2C1_IRQn);
00007e  2013              MOVS     r0,#0x13
000080  f7fffffe          BL       __NVIC_EnableIRQ
;;;700    }
000084  bd10              POP      {r4,pc}
;;;701    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x04000009
                  |L7.140|
                          DCD      0x000186a0
                  |L7.144|
                          DCD      0x40120000
                  |L7.148|
000094  49324331          DCB      "I2C1 clock %d Hz\n",0
000098  20636c6f
00009c  636b2025
0000a0  6420487a
0000a4  0a00    
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.I2C_MasterRx||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  I2C_MasterRx PROC
;;;167    /*---------------------------------------------------------------------------------------------------------*/
;;;168    void I2C_MasterRx(uint32_t u32Status)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170        if(u32Status == 0x08)                       /* START has been transmitted and prepare SLA+W */
;;;171        {
;;;172            I2C_SET_DATA(I2C0, (g_u8DeviceAddr << 1));    /* Write SLA+W to Register I2CDAT */
000002  491f              LDR      r1,|L8.128|
;;;173            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
000004  223c              MOVS     r2,#0x3c
000006  4b1f              LDR      r3,|L8.132|
000008  2808              CMP      r0,#8                 ;170
00000a  d011              BEQ      |L8.48|
;;;174        }
;;;175        else if(u32Status == 0x18)                  /* SLA+W has been transmitted and ACK has been received */
;;;176        {
;;;177            I2C_SET_DATA(I2C0, g_au8MstTxData[g_u8MstDataLen++]);
00000c  4c1e              LDR      r4,|L8.136|
00000e  2818              CMP      r0,#0x18              ;175
000010  d021              BEQ      |L8.86|
;;;178            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
;;;179        }
;;;180        else if(u32Status == 0x20)                  /* SLA+W has been transmitted and NACK has been received */
000012  2820              CMP      r0,#0x20
000014  d014              BEQ      |L8.64|
;;;181        {
;;;182            I2C_STOP(I2C0);
;;;183            I2C_START(I2C0);
;;;184        }
;;;185        else if(u32Status == 0x28)                  /* DATA has been transmitted and ACK has been received */
000016  2828              CMP      r0,#0x28
000018  d01a              BEQ      |L8.80|
;;;186        {
;;;187            if (g_u8MstDataLen != (I2C_DATA_MAX - 2))	//(g_u8MstDataLen != 2)
;;;188            {
;;;189                I2C_SET_DATA(I2C0, g_au8MstTxData[g_u8MstDataLen++]);
;;;190                I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
;;;191            }
;;;192            else
;;;193            {
;;;194                I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA_SI);
;;;195            }
;;;196        }
;;;197        else if(u32Status == 0x10)                  /* Repeat START has been transmitted and prepare SLA+R */
00001a  2810              CMP      r0,#0x10
00001c  d025              BEQ      |L8.106|
;;;198        {
;;;199            I2C_SET_DATA(I2C0, ((g_u8DeviceAddr << 1) | 0x01));   /* Write SLA+R to Register I2CDAT */
;;;200            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
;;;201        }
;;;202        else if(u32Status == 0x40)                  /* SLA+R has been transmitted and ACK has been received */
00001e  2840              CMP      r0,#0x40
000020  d009              BEQ      |L8.54|
;;;203        {
;;;204            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
;;;205        }
;;;206        else if(u32Status == 0x58)                  /* DATA has been received and NACK has been returned */
000022  2858              CMP      r0,#0x58
000024  d025              BEQ      |L8.114|
;;;207        {
;;;208    //        g_u8MstRxData = (unsigned char) I2C_GET_DATA(I2C0);
;;;209            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO_SI);
;;;210            g_u8MstEndFlag = 1;
;;;211        }
;;;212        else
;;;213        {
;;;214            /* TO DO */
;;;215            printf("Status 0x%x is NOT processed\n", u32Status);
000026  4601              MOV      r1,r0
000028  a018              ADR      r0,|L8.140|
00002a  f7fffffe          BL       __2printf
;;;216        }
;;;217    }
00002e  bd10              POP      {r4,pc}
                  |L8.48|
000030  7a58              LDRB     r0,[r3,#9]            ;172  ; g_u8DeviceAddr
000032  0040              LSLS     r0,r0,#1              ;172
                  |L8.52|
000034  6088              STR      r0,[r1,#8]            ;172
                  |L8.54|
000036  6808              LDR      r0,[r1,#0]            ;204
000038  4390              BICS     r0,r0,r2              ;204
00003a  3008              ADDS     r0,r0,#8              ;204
                  |L8.60|
00003c  6008              STR      r0,[r1,#0]            ;173
00003e  bd10              POP      {r4,pc}
                  |L8.64|
000040  6808              LDR      r0,[r1,#0]            ;182
000042  2218              MOVS     r2,#0x18              ;182
000044  4310              ORRS     r0,r0,r2              ;182
000046  6008              STR      r0,[r1,#0]            ;182
000048  6808              LDR      r0,[r1,#0]            ;183
00004a  2228              MOVS     r2,#0x28              ;183
00004c  4310              ORRS     r0,r0,r2              ;183
00004e  e7f5              B        |L8.60|
                  |L8.80|
000050  7a98              LDRB     r0,[r3,#0xa]          ;187  ; g_u8MstDataLen
000052  2816              CMP      r0,#0x16              ;187
000054  d005              BEQ      |L8.98|
                  |L8.86|
000056  7a98              LDRB     r0,[r3,#0xa]          ;189  ; g_u8MstDataLen
000058  1824              ADDS     r4,r4,r0              ;189
00005a  1c40              ADDS     r0,r0,#1              ;189
00005c  7298              STRB     r0,[r3,#0xa]          ;189
00005e  7820              LDRB     r0,[r4,#0]            ;189
000060  e7e8              B        |L8.52|
                  |L8.98|
000062  6808              LDR      r0,[r1,#0]            ;194
000064  4390              BICS     r0,r0,r2              ;194
000066  3028              ADDS     r0,r0,#0x28           ;194
000068  e7e8              B        |L8.60|
                  |L8.106|
00006a  7a58              LDRB     r0,[r3,#9]            ;199  ; g_u8DeviceAddr
00006c  0040              LSLS     r0,r0,#1              ;199
00006e  1c40              ADDS     r0,r0,#1              ;199
000070  e7e0              B        |L8.52|
                  |L8.114|
000072  6808              LDR      r0,[r1,#0]            ;209
000074  4390              BICS     r0,r0,r2              ;209
000076  3018              ADDS     r0,r0,#0x18           ;209
000078  6008              STR      r0,[r1,#0]            ;209
00007a  2001              MOVS     r0,#1                 ;210
00007c  7018              STRB     r0,[r3,#0]            ;210
00007e  bd10              POP      {r4,pc}
;;;218    
                          ENDP

                  |L8.128|
                          DCD      0x40020000
                  |L8.132|
                          DCD      ||.data||
                  |L8.136|
                          DCD      ||.bss||+0x62
                  |L8.140|
00008c  53746174          DCB      "Status 0x%x is NOT processed\n",0
000090  75732030
000094  78257820
000098  6973204e
00009c  4f542070
0000a0  726f6365
0000a4  73736564
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.I2C_MasterTx||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  I2C_MasterTx PROC
;;;221    /*---------------------------------------------------------------------------------------------------------*/
;;;222    void I2C_MasterTx(uint32_t u32Status)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224        if(u32Status == 0x08)                       /* START has been transmitted */
;;;225        {
;;;226            I2C_SET_DATA(I2C0, g_u8DeviceAddr << 1);    /* Write SLA+W to Register I2CDAT */
000002  4918              LDR      r1,|L9.100|
;;;227            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
000004  223c              MOVS     r2,#0x3c
000006  4b18              LDR      r3,|L9.104|
000008  2808              CMP      r0,#8                 ;224
00000a  d00b              BEQ      |L9.36|
;;;228        }
;;;229        else if(u32Status == 0x18)                  /* SLA+W has been transmitted and ACK has been received */
;;;230        {
;;;231            I2C_SET_DATA(I2C0, g_au8MstTxData[g_u8MstDataLen++]);
00000c  4c17              LDR      r4,|L9.108|
00000e  2818              CMP      r0,#0x18              ;229
000010  d01b              BEQ      |L9.74|
;;;232            I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
;;;233        }
;;;234        else if(u32Status == 0x20)                  /* SLA+W has been transmitted and NACK has been received */
000012  2820              CMP      r0,#0x20
000014  d00e              BEQ      |L9.52|
;;;235        {
;;;236            I2C_STOP(I2C0);
;;;237            I2C_START(I2C0);
;;;238        }
;;;239        else if(u32Status == 0x28)                  /* DATA has been transmitted and ACK has been received */
000016  2828              CMP      r0,#0x28
000018  d014              BEQ      |L9.68|
;;;240        {
;;;241            if (g_u8MstDataLen != I2C_DATA_MAX)	//(g_u8MstDataLen != 3)
;;;242            {
;;;243                I2C_SET_DATA(I2C0, g_au8MstTxData[g_u8MstDataLen++]);
;;;244                I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
;;;245            }
;;;246            else
;;;247            {
;;;248                I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO_SI);
;;;249                g_u8MstEndFlag = 1;
;;;250            }
;;;251        }
;;;252        else
;;;253        {
;;;254            /* TO DO */
;;;255            printf("Status 0x%x is NOT processed\n", u32Status);
00001a  4601              MOV      r1,r0
00001c  a014              ADR      r0,|L9.112|
00001e  f7fffffe          BL       __2printf
;;;256        }
;;;257    }
000022  bd10              POP      {r4,pc}
                  |L9.36|
000024  7a58              LDRB     r0,[r3,#9]            ;226  ; g_u8DeviceAddr
000026  0040              LSLS     r0,r0,#1              ;226
                  |L9.40|
000028  6088              STR      r0,[r1,#8]            ;226
00002a  6808              LDR      r0,[r1,#0]            ;227
00002c  4390              BICS     r0,r0,r2              ;227
00002e  3008              ADDS     r0,r0,#8              ;227
                  |L9.48|
000030  6008              STR      r0,[r1,#0]            ;227
000032  bd10              POP      {r4,pc}
                  |L9.52|
000034  6808              LDR      r0,[r1,#0]            ;236
000036  2218              MOVS     r2,#0x18              ;236
000038  4310              ORRS     r0,r0,r2              ;236
00003a  6008              STR      r0,[r1,#0]            ;236
00003c  6808              LDR      r0,[r1,#0]            ;237
00003e  2228              MOVS     r2,#0x28              ;237
000040  4310              ORRS     r0,r0,r2              ;237
000042  e7f5              B        |L9.48|
                  |L9.68|
000044  7a98              LDRB     r0,[r3,#0xa]          ;241  ; g_u8MstDataLen
000046  2818              CMP      r0,#0x18              ;241
000048  d005              BEQ      |L9.86|
                  |L9.74|
00004a  7a98              LDRB     r0,[r3,#0xa]          ;243  ; g_u8MstDataLen
00004c  1824              ADDS     r4,r4,r0              ;243
00004e  1c40              ADDS     r0,r0,#1              ;243
000050  7298              STRB     r0,[r3,#0xa]          ;243
000052  7820              LDRB     r0,[r4,#0]            ;243
000054  e7e8              B        |L9.40|
                  |L9.86|
000056  6808              LDR      r0,[r1,#0]            ;248
000058  4390              BICS     r0,r0,r2              ;248
00005a  3018              ADDS     r0,r0,#0x18           ;248
00005c  6008              STR      r0,[r1,#0]            ;248
00005e  2001              MOVS     r0,#1                 ;249
000060  7018              STRB     r0,[r3,#0]            ;249
000062  bd10              POP      {r4,pc}
;;;258    
                          ENDP

                  |L9.100|
                          DCD      0x40020000
                  |L9.104|
                          DCD      ||.data||
                  |L9.108|
                          DCD      ||.bss||+0x62
                  |L9.112|
000070  53746174          DCB      "Status 0x%x is NOT processed\n",0
000074  75732030
000078  78257820
00007c  6973204e
000080  4f542070
000084  726f6365
000088  73736564
00008c  0a00    
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.I2C_SlaveTRx||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTRx PROC
;;;387    
;;;388    void I2C_SlaveTRx(uint32_t u32Status)
000000  b5fe              PUSH     {r1-r7,lr}
;;;389    {
;;;390    #if 1
;;;391    	uint8_t u8RxData = 0;
000002  2100              MOVS     r1,#0
000004  466a              MOV      r2,sp
000006  7011              STRB     r1,[r2,#0]
;;;392    	uint8_t u8TxData = 0;
000008  7111              STRB     r1,[r2,#4]
;;;393    	uint8_t u8TempData = 0;	
00000a  7211              STRB     r1,[r2,#8]
;;;394    	uint16_t u16Rxlen = 0;
;;;395    	
;;;396        if(u32Status == SLAVE_RECEIVE_ADDRESS_ACK) //0x60                    	/* Own SLA+W has been receive; ACK has been return */
;;;397        {
;;;398            g_u8DataLen_s = 0;
;;;399    
;;;400    		I2C_Slave_StateMachine(u32Status , &u8TempData , &u8TempData);
;;;401    		
;;;402            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI | I2C_CTL_AA);
00000c  253c              MOVS     r5,#0x3c
00000e  4a23              LDR      r2,|L10.156|
000010  4c23              LDR      r4,|L10.160|
000012  2860              CMP      r0,#0x60              ;396
000014  d013              BEQ      |L10.62|
;;;403    
;;;404        }
;;;405        else if(u32Status == SLAVE_RECEIVE_DATA_ACK) //0x80                 		/* Previously address with own SLA address
;;;406    																			/* Data has been received; ACK has been returned*/
;;;407        {
;;;408            u8RxData = (unsigned char) I2C_GET_DATA(I2C1);
;;;409    		
;;;410    //		__I2Cx_Slave_LogBuffer__(u32Status , g_u8RxData);		
;;;411    
;;;412    	    g_u8DataLen_s++;
;;;413    
;;;414    	    if(g_u8DataLen_s == 1)
;;;415    	    {
;;;416    			/*
;;;417    				Blind spot : register address can not larger than g_u8SlvData array size , 
;;;418    				due to resister address will be save as array start index to store data
;;;419    			
;;;420    			*/
;;;421    	        slave_buff_addr = u8RxData;	//register
;;;422    					
;;;423    	    }
;;;424    	    else
;;;425    	    {
;;;426    			u16Rxlen = slave_buff_addr+(g_u8DataLen_s-2);		//data buffer start	
;;;427    	        g_au8SlvData[u16Rxlen] = u8RxData;
000016  4b23              LDR      r3,|L10.164|
000018  2880              CMP      r0,#0x80              ;405
00001a  d014              BEQ      |L10.70|
;;;428    		
;;;429    	    }
;;;430    	
;;;431    		I2C_Slave_StateMachine(u32Status , &u8RxData , &u8TempData);
;;;432    				
;;;433            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI | I2C_CTL_AA);
;;;434    
;;;435        }
;;;436        else if(u32Status == SLAVE_TRANSMIT_ADDRESS_ACK) //0xA8               	/* Own SLA+R has been receive; ACK has been return */
00001c  28a8              CMP      r0,#0xa8
00001e  d02c              BEQ      |L10.122|
;;;437        {
;;;438    		u8RxData = g_au8SlvData[slave_buff_addr++];
;;;439    
;;;440    		I2C_Slave_StateMachine(u32Status , &u8RxData, &u8TxData);	
;;;441    
;;;442    //		I2C_SET_DATA(I2C1, u8RxData);
;;;443         	I2C_SET_DATA(I2C1, u8TxData);	
;;;444            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI | I2C_CTL_AA);
;;;445    
;;;446        }
;;;447    	else if(u32Status == SLAVE_TRANSMIT_DATA_ACK) //0xB8                 	/* Data byte in I2CDAT has been transmitted
000020  28b8              CMP      r0,#0xb8
000022  d02a              BEQ      |L10.122|
;;;448    																			/* ACK has been received */
;;;449        {
;;;450    		u8RxData = g_au8SlvData[slave_buff_addr++];
;;;451    
;;;452    		I2C_Slave_StateMachine(u32Status , &u8RxData, &u8TxData);
;;;453    
;;;454    //		I2C_SET_DATA(I2C1, u8RxData);
;;;455    		I2C_SET_DATA(I2C1, u8TxData);	
;;;456    		I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI | I2C_CTL_AA);
;;;457    		
;;;458        }
;;;459        else if(u32Status == SLAVE_TRANSMIT_DATA_NACK) //0xC0                 	/* Data byte or last data in I2CDAT has been transmitted
000024  28c0              CMP      r0,#0xc0
000026  d00b              BEQ      |L10.64|
;;;460    																			/* Not ACK has been received */
;;;461        {
;;;462    		I2C_Slave_StateMachine(u32Status , &u8TempData , &u8TempData);
;;;463    	
;;;464            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI | I2C_CTL_AA);
;;;465    		
;;;466    
;;;467        }
;;;468        else if(u32Status == SLAVE_RECEIVE_DATA_NACK) //0x88                 		/* Previously addressed with own SLA address; NOT ACK has
000028  2888              CMP      r0,#0x88
00002a  d035              BEQ      |L10.152|
;;;469    																			/* been returned */
;;;470        {
;;;471            g_u8DataLen_s = 0;
;;;472            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI | I2C_CTL_AA);
;;;473    
;;;474        }
;;;475        else if(u32Status == SLAVE_TRANSMIT_REPEAT_START_OR_STOP) //0xA0    		/* A STOP or repeated START has been received while still
00002c  28a0              CMP      r0,#0xa0
00002e  d006              BEQ      |L10.62|
;;;476    																			/* addressed as Slave/Receiver*/
;;;477        {
;;;478            g_u8DataLen_s = 0;
;;;479    		I2C_Slave_StateMachine(u32Status , &u8TempData, &u8TempData);
;;;480    		
;;;481            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI | I2C_CTL_AA);
;;;482    
;;;483        }
;;;484        else if(u32Status == BUS_ERROR) //0x00
000030  2800              CMP      r0,#0
000032  d11f              BNE      |L10.116|
;;;485        {
;;;486    		I2C_SET_CONTROL_REG(I2C1, I2C_CTL_STO_SI_AA);
000034  6820              LDR      r0,[r4,#0]
000036  43a8              BICS     r0,r0,r5
000038  301c              ADDS     r0,r0,#0x1c
00003a  6020              STR      r0,[r4,#0]
;;;487    		I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
00003c  e016              B        |L10.108|
                  |L10.62|
00003e  70d1              STRB     r1,[r2,#3]            ;398
                  |L10.64|
000040  aa02              ADD      r2,sp,#8              ;462
000042  4611              MOV      r1,r2                 ;462
000044  e010              B        |L10.104|
                  |L10.70|
000046  68a1              LDR      r1,[r4,#8]            ;408
000048  b2ce              UXTB     r6,r1                 ;408
00004a  4669              MOV      r1,sp                 ;408
00004c  700e              STRB     r6,[r1,#0]            ;408
00004e  78d1              LDRB     r1,[r2,#3]            ;412  ; g_u8DataLen_s
000050  1c49              ADDS     r1,r1,#1              ;412
000052  b2c9              UXTB     r1,r1                 ;412
000054  70d1              STRB     r1,[r2,#3]            ;412
000056  2901              CMP      r1,#1                 ;414
000058  d00d              BEQ      |L10.118|
00005a  69d2              LDR      r2,[r2,#0x1c]         ;426  ; slave_buff_addr
00005c  1851              ADDS     r1,r2,r1              ;426
00005e  1e89              SUBS     r1,r1,#2              ;426
000060  b289              UXTH     r1,r1                 ;426
000062  545e              STRB     r6,[r3,r1]            ;427
                  |L10.100|
000064  aa02              ADD      r2,sp,#8              ;431
000066  4669              MOV      r1,sp                 ;431
                  |L10.104|
000068  f7fffffe          BL       I2C_Slave_StateMachine
                  |L10.108|
00006c  6820              LDR      r0,[r4,#0]            ;402
00006e  43a8              BICS     r0,r0,r5              ;402
000070  300c              ADDS     r0,r0,#0xc            ;402
000072  6020              STR      r0,[r4,#0]            ;402
                  |L10.116|
;;;488    	
;;;489        }																	
;;;490        else
;;;491        {
;;;492    		#if defined (DEBUG_LOG_SLAVE_LV2)
;;;493            /* TO DO */
;;;494            printf("I2Cx_SlaveTRx Status 0x%x is NOT processed\n", u32Status);
;;;495    		#endif
;;;496        }
;;;497    #else
;;;498    
;;;499        if(u32Status == 0x60)                       /* Own SLA+W has been receive; ACK has been return */
;;;500        {
;;;501            g_u8SlvDataLen = 0;
;;;502            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
;;;503        }
;;;504        else if(u32Status == 0x80)                 /* Previously address with own SLA address
;;;505                                                       Data has been received; ACK has been returned*/
;;;506        {
;;;507            g_au8SlvRxData[g_u8SlvDataLen] = (unsigned char) I2C_GET_DATA(I2C1);
;;;508            g_u8SlvDataLen++;
;;;509    
;;;510            if(g_u8SlvDataLen == 2)
;;;511            {
;;;512                slave_buff_addr = (g_au8SlvRxData[0] << 8) + g_au8SlvRxData[1];
;;;513            }
;;;514            if(g_u8SlvDataLen == 3)
;;;515            {
;;;516                g_au8SlvData[slave_buff_addr] = g_au8SlvRxData[2];
;;;517                g_u8SlvDataLen = 0;
;;;518            }
;;;519    
;;;520            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
;;;521        }
;;;522        else if(u32Status == 0xA8)                  /* Own SLA+R has been receive; ACK has been return */
;;;523        {
;;;524            I2C_SET_DATA(I2C1, g_au8SlvData[slave_buff_addr]);
;;;525            slave_buff_addr++;
;;;526            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
;;;527        }
;;;528        else if(u32Status == 0xC0)                 /* Data byte or last data in I2CDAT has been transmitted
;;;529                                                       Not ACK has been received */
;;;530        {
;;;531            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
;;;532        }
;;;533        else if(u32Status == 0x88)                 /* Previously addressed with own SLA address; NOT ACK has
;;;534                                                       been returned */
;;;535        {
;;;536            g_u8SlvDataLen = 0;
;;;537            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
;;;538        }
;;;539        else if(u32Status == 0xA0)                 /* A STOP or repeated START has been received while still
;;;540                                                       addressed as Slave/Receiver*/
;;;541        {
;;;542            g_u8SlvDataLen = 0;
;;;543            I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
;;;544        }
;;;545        else
;;;546        {
;;;547            /* TO DO */
;;;548            printf("Status 0x%x is NOT processed\n", u32Status);
;;;549        }
;;;550    #endif	
;;;551    }
000074  bdfe              POP      {r1-r7,pc}
                  |L10.118|
000076  61d6              STR      r6,[r2,#0x1c]         ;421  ; slave_buff_addr
000078  e7f4              B        |L10.100|
                  |L10.122|
00007a  69d1              LDR      r1,[r2,#0x1c]         ;450  ; slave_buff_addr
00007c  185b              ADDS     r3,r3,r1              ;450
00007e  1c49              ADDS     r1,r1,#1              ;450
000080  61d1              STR      r1,[r2,#0x1c]         ;450  ; slave_buff_addr
000082  7819              LDRB     r1,[r3,#0]            ;450
000084  466a              MOV      r2,sp                 ;450
000086  7011              STRB     r1,[r2,#0]            ;450
000088  aa01              ADD      r2,sp,#4              ;452
00008a  4669              MOV      r1,sp                 ;452
00008c  f7fffffe          BL       I2C_Slave_StateMachine
000090  466a              MOV      r2,sp                 ;455
000092  7910              LDRB     r0,[r2,#4]            ;455
000094  60a0              STR      r0,[r4,#8]            ;455
000096  e7e9              B        |L10.108|
                  |L10.152|
000098  70d1              STRB     r1,[r2,#3]            ;471
00009a  e7e7              B        |L10.108|
;;;552    void SYS_Init(void)
                          ENDP

                  |L10.156|
                          DCD      ||.data||
                  |L10.160|
                          DCD      0x40120000
                  |L10.164|
                          DCD      ||.bss||+0x7a

                          AREA ||i.I2C_Slave_ReturnTx||, CODE, READONLY, ALIGN=2

                  I2C_Slave_ReturnTx PROC
;;;262    
;;;263    void I2C_Slave_ReturnTx(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;264    {
;;;265    	uint8_t i = 0;	
000002  2000              MOVS     r0,#0
;;;266    
;;;267    	// clear tx buffer
;;;268    	for (i = 0; i <64 ; i++)
;;;269    	{
;;;270    		g_u8ToMasterData[i] = 0x00;
000004  4b0c              LDR      r3,|L11.56|
000006  4602              MOV      r2,r0                 ;265
                  |L11.8|
000008  541a              STRB     r2,[r3,r0]
00000a  1c40              ADDS     r0,r0,#1
00000c  b2c0              UXTB     r0,r0                 ;268
00000e  2840              CMP      r0,#0x40              ;268
000010  d3fa              BCC      |L11.8|
;;;271    	}
;;;272    	// swap the data 
;;;273    	for (i = 0; i < g_u8temporary; i++)
;;;274    	{
;;;275    		g_u8ToMasterData[(g_u8temporary-1)-i] = g_u8FromMasterData[i];
000012  4d0a              LDR      r5,|L11.60|
000014  4c08              LDR      r4,|L11.56|
000016  2000              MOVS     r0,#0                 ;273
000018  79e9              LDRB     r1,[r5,#7]
00001a  3418              ADDS     r4,r4,#0x18
00001c  e006              B        |L11.44|
                  |L11.30|
00001e  1a0f              SUBS     r7,r1,r0
000020  18ff              ADDS     r7,r7,r3
000022  5c26              LDRB     r6,[r4,r0]
000024  3f20              SUBS     r7,r7,#0x20
000026  1c40              ADDS     r0,r0,#1
000028  77fe              STRB     r6,[r7,#0x1f]
00002a  b2c0              UXTB     r0,r0                 ;273
                  |L11.44|
00002c  4288              CMP      r0,r1                 ;273
00002e  d3f6              BCC      |L11.30|
;;;276    //		printf("From : 0x%2X, To : 0x%2X,\r\n" , g_u8FromMasterData[i],g_u8ToMasterData[i]);
;;;277    	}
;;;278    
;;;279    	g_u8FromMasterLen = 0;
000030  716a              STRB     r2,[r5,#5]
;;;280    	g_u8ToMasterLen = 0;
000032  712a              STRB     r2,[r5,#4]
;;;281    	g_u8temporary = 0;
000034  71ea              STRB     r2,[r5,#7]
;;;282    }
000036  bdf0              POP      {r4-r7,pc}
;;;283    
                          ENDP

                  |L11.56|
                          DCD      ||.bss||+0x32
                  |L11.60|
                          DCD      ||.data||

                          AREA ||i.I2C_Slave_StateMachine||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C_Slave_StateMachine PROC
;;;284    
;;;285    void I2C_Slave_StateMachine(uint32_t res , uint8_t* InData, uint8_t* OutData)
000000  b5f8              PUSH     {r3-r7,lr}
;;;286    {
000002  2600              MOVS     r6,#0
;;;287    //	uint8_t i = 0;	
;;;288    //	static uint8_t u8Temp = 0;
;;;289    	static uint8_t cnt = _state_DEFAULT_;
;;;290    	
;;;291    	if (res == SLAVE_RECEIVE_ADDRESS_ACK)	//no this ack when not receive register address
;;;292    	{
;;;293    		cnt = _state_RECEIVE_ADDRESS_;
000004  4c2e              LDR      r4,|L12.192|
000006  4615              MOV      r5,r2                 ;286
000008  2860              CMP      r0,#0x60              ;291
00000a  d104              BNE      |L12.22|
00000c  2201              MOVS     r2,#1
00000e  7222              STRB     r2,[r4,#8]
;;;294    		slave_register_addr = 0;
000010  71a6              STRB     r6,[r4,#6]
;;;295    		g_u8FromMasterLen = 0;
000012  7166              STRB     r6,[r4,#5]
;;;296    		g_u8ToMasterLen = 0;		
000014  7126              STRB     r6,[r4,#4]
                  |L12.22|
;;;297    	}
;;;298    
;;;299    	switch(cnt)
000016  7a22              LDRB     r2,[r4,#8]  ; cnt
000018  2a01              CMP      r2,#1
00001a  d016              BEQ      |L12.74|
00001c  2704              MOVS     r7,#4                 ;293
;;;300    	{
;;;301    		case _state_RECEIVE_ADDRESS_:
;;;302    			if (res == SLAVE_RECEIVE_DATA_ACK)	
;;;303    			{
;;;304    				// first 0x80 ack is register address
;;;305    				if(g_u8DataLen_s == 1)
;;;306    				{
;;;307    					slave_register_addr = slave_buff_addr;
;;;308    					printf("-----------------\r\n");
;;;309    					printf("DATA = 0x%2X\r\n" , slave_register_addr);
;;;310    				}
;;;311    				cnt = _state_CHECK_RX_OR_TX_;
;;;312    			}
;;;313    			break;
;;;314    
;;;315    		case _state_CHECK_RX_OR_TX_:
;;;316    			if (res == SLAVE_RECEIVE_DATA_ACK)	
;;;317    			{
;;;318    				// RX : contiune with multi 0x80 , end with 0xA0
;;;319    				// example : 0x60 > 0x80 (address) > 0x80 (data00)> 0x80 (data01) > ...> 0xA0
;;;320    				g_u8FromMasterData[g_u8FromMasterLen++] =  *InData;
00001e  4b29              LDR      r3,|L12.196|
000020  2a02              CMP      r2,#2                 ;299
000022  d022              BEQ      |L12.106|
000024  2a03              CMP      r2,#3                 ;299
000026  d02e              BEQ      |L12.134|
000028  2a04              CMP      r2,#4                 ;299
00002a  d10d              BNE      |L12.72|
;;;321    				cnt = _state_RECEIVE_RX_;
;;;322    			}
;;;323    			else if (res == SLAVE_TRANSMIT_REPEAT_START_OR_STOP)	
;;;324    			{
;;;325    				// if use I2C_ReadMultiBytesOneReg , 
;;;326    				// ack will act as below , 0x60 > 0x80 > 0xA0 > 0xA8 > 0xB8
;;;327    				// TX : following with 0xA0 , and 0xA8 (data01) , continue with 0xB8 (Data02)  , end with 0xC0
;;;328    				// example : 0x60 > 0x80 (address) > 0xA8 (data00) > 0xB8  (data01)> 0xB8  (data02) > ... > 0xC0
;;;329    				
;;;330    				cnt = _state_TRANSMIT_TX_;
;;;331    				
;;;332    			}
;;;333    			break;
;;;334    
;;;335    		case _state_RECEIVE_RX_:
;;;336    			if (res == SLAVE_TRANSMIT_REPEAT_START_OR_STOP)	
;;;337    			{
;;;338    				// end of RX
;;;339    
;;;340    				printf("g_u8FromMasterLen = %d\r\n" , g_u8FromMasterLen);
;;;341    				g_u8temporary = g_u8FromMasterLen;
;;;342    
;;;343    				// if use I2C_ReadMultiBytes , 
;;;344    				// ack will act as below , 0xA8 > 0xB8 > 0xB8 > ... > 0xC0
;;;345    				// so change state machine here
;;;346    				// must follow with 
;;;347    				// 1) I2C_WriteMultiBytes , I2C_ReadMultiBytes , or
;;;348    				// 2) I2C_WriteMultiBytesOneReg , , I2C_ReadMultiBytes
;;;349    				// 3) directlly by using I2C_ReadMultiBytes , will be no data transfer
;;;350    				
;;;351    //				cnt = _state_DEFAULT_;	//reset flag
;;;352    				cnt = _state_TRANSMIT_TX_;
;;;353    				
;;;354    			}
;;;355    			else if (res == SLAVE_RECEIVE_DATA_ACK)
;;;356    			{
;;;357    				// continue to get data
;;;358    				g_u8FromMasterData[g_u8FromMasterLen++] =  *InData;
;;;359    			}
;;;360    			break;
;;;361    
;;;362    		case _state_TRANSMIT_TX_:
;;;363    			if (res == SLAVE_TRANSMIT_ADDRESS_ACK)	
;;;364    			{
;;;365    				I2C_Slave_ReturnTx();
;;;366    				
;;;367    				// first TX byte				
;;;368    				*OutData = g_u8ToMasterData[g_u8ToMasterLen++];
00002c  461f              MOV      r7,r3
00002e  3f18              SUBS     r7,r7,#0x18
000030  28a8              CMP      r0,#0xa8              ;363
000032  d039              BEQ      |L12.168|
;;;369    			}
;;;370    			else if (res == SLAVE_TRANSMIT_DATA_NACK)	
000034  28c0              CMP      r0,#0xc0
000036  d03a              BEQ      |L12.174|
;;;371    			{
;;;372    				// end of TX
;;;373    				printf("g_u8ToMasterLen = %d\r\n" , g_u8ToMasterLen);
;;;374    				printf("-----------------\r\n\r\n");
;;;375    				cnt = _state_DEFAULT_;	//reset flag
;;;376    			}
;;;377    			else if (res == SLAVE_TRANSMIT_DATA_ACK)
000038  28b8              CMP      r0,#0xb8
00003a  d105              BNE      |L12.72|
                  |L12.60|
;;;378    			{
;;;379    				// continue to send data
;;;380    				*OutData = g_u8ToMasterData[g_u8ToMasterLen++];
00003c  7920              LDRB     r0,[r4,#4]  ; g_u8ToMasterLen
00003e  5c38              LDRB     r0,[r7,r0]
000040  7028              STRB     r0,[r5,#0]
000042  7920              LDRB     r0,[r4,#4]  ; g_u8ToMasterLen
000044  1c40              ADDS     r0,r0,#1
000046  7120              STRB     r0,[r4,#4]
                  |L12.72|
;;;381    			}
;;;382    			break;
;;;383    
;;;384    			
;;;385    	}
;;;386    }
000048  bdf8              POP      {r3-r7,pc}
                  |L12.74|
00004a  2880              CMP      r0,#0x80              ;302
00004c  d1fc              BNE      |L12.72|
00004e  78e0              LDRB     r0,[r4,#3]            ;305  ; g_u8DataLen_s
000050  2801              CMP      r0,#1                 ;305
000052  d108              BNE      |L12.102|
000054  69e0              LDR      r0,[r4,#0x1c]         ;307  ; slave_buff_addr
000056  71a0              STRB     r0,[r4,#6]            ;307
000058  a01b              ADR      r0,|L12.200|
00005a  f7fffffe          BL       __2printf
00005e  79a1              LDRB     r1,[r4,#6]            ;309  ; slave_register_addr
000060  a01e              ADR      r0,|L12.220|
000062  f7fffffe          BL       __2printf
                  |L12.102|
000066  2002              MOVS     r0,#2                 ;311
000068  e00b              B        |L12.130|
                  |L12.106|
00006a  2880              CMP      r0,#0x80              ;316
00006c  d003              BEQ      |L12.118|
00006e  28a0              CMP      r0,#0xa0              ;323
000070  d1ea              BNE      |L12.72|
                  |L12.114|
000072  7227              STRB     r7,[r4,#8]            ;330
000074  bdf8              POP      {r3-r7,pc}
                  |L12.118|
000076  7960              LDRB     r0,[r4,#5]            ;320  ; g_u8FromMasterLen
000078  7809              LDRB     r1,[r1,#0]            ;320
00007a  5419              STRB     r1,[r3,r0]            ;320
00007c  1c40              ADDS     r0,r0,#1              ;320
00007e  7160              STRB     r0,[r4,#5]            ;320
000080  2003              MOVS     r0,#3                 ;321
                  |L12.130|
000082  7220              STRB     r0,[r4,#8]            ;311
                  |L12.132|
000084  bdf8              POP      {r3-r7,pc}
                  |L12.134|
000086  28a0              CMP      r0,#0xa0              ;336
000088  d007              BEQ      |L12.154|
00008a  2880              CMP      r0,#0x80              ;355
00008c  d1fa              BNE      |L12.132|
00008e  7960              LDRB     r0,[r4,#5]            ;358  ; g_u8FromMasterLen
000090  7809              LDRB     r1,[r1,#0]            ;358
000092  5419              STRB     r1,[r3,r0]            ;358
000094  1c40              ADDS     r0,r0,#1              ;358
000096  7160              STRB     r0,[r4,#5]            ;358
000098  bdf8              POP      {r3-r7,pc}
                  |L12.154|
00009a  7961              LDRB     r1,[r4,#5]            ;340  ; g_u8FromMasterLen
00009c  a013              ADR      r0,|L12.236|
00009e  f7fffffe          BL       __2printf
0000a2  7960              LDRB     r0,[r4,#5]            ;341  ; g_u8FromMasterLen
0000a4  71e0              STRB     r0,[r4,#7]            ;341
0000a6  e7e4              B        |L12.114|
                  |L12.168|
0000a8  f7fffffe          BL       I2C_Slave_ReturnTx
0000ac  e7c6              B        |L12.60|
                  |L12.174|
0000ae  7921              LDRB     r1,[r4,#4]            ;373  ; g_u8ToMasterLen
0000b0  a015              ADR      r0,|L12.264|
0000b2  f7fffffe          BL       __2printf
0000b6  a01a              ADR      r0,|L12.288|
0000b8  f7fffffe          BL       __2printf
0000bc  7226              STRB     r6,[r4,#8]            ;375
0000be  bdf8              POP      {r3-r7,pc}
;;;387    
                          ENDP

                  |L12.192|
                          DCD      ||.data||
                  |L12.196|
                          DCD      ||.bss||+0x4a
                  |L12.200|
0000c8  2d2d2d2d          DCB      "-----------------\r\n",0
0000cc  2d2d2d2d
0000d0  2d2d2d2d
0000d4  2d2d2d2d
0000d8  2d0d0a00
                  |L12.220|
0000dc  44415441          DCB      "DATA = 0x%2X\r\n",0
0000e0  203d2030
0000e4  78253258
0000e8  0d0a00  
0000eb  00                DCB      0
                  |L12.236|
0000ec  675f7538          DCB      "g_u8FromMasterLen = %d\r\n",0
0000f0  46726f6d
0000f4  4d617374
0000f8  65724c65
0000fc  6e203d20
000100  25640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L12.264|
000108  675f7538          DCB      "g_u8ToMasterLen = %d\r\n",0
00010c  546f4d61
000110  73746572
000114  4c656e20
000118  3d202564
00011c  0d0a00  
00011f  00                DCB      0
                  |L12.288|
000120  2d2d2d2d          DCB      "-----------------\r\n\r\n",0
000124  2d2d2d2d
000128  2d2d2d2d
00012c  2d2d2d2d
000130  2d0d0a0d
000134  0a00    
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;551    }
;;;552    void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;553    {
;;;554        /*---------------------------------------------------------------------------------------------------------*/
;;;555        /* Init System Clock                                                                                       */
;;;556        /*---------------------------------------------------------------------------------------------------------*/
;;;557    
;;;558        /* Enable Internal RC 22.1184MHz clock */
;;;559        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       CLK_EnableXtalRC
;;;560    
;;;561        /* Waiting for Internal RC clock ready */
;;;562        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       CLK_WaitClockReady
;;;563    
;;;564        /* Switch HCLK clock source to Internal RC and HCLK source divide 1 */
;;;565        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HXT, CLK_CLKDIV0_HCLK(1));
00000e  2100              MOVS     r1,#0
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       CLK_SetHCLK
;;;566    
;;;567        /* Enable external XTAL 12MHz clock */
;;;568    	#if defined (ENABLE_NUC125)
;;;569        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;570    	#elif defined (ENABLE_NUC126)
;;;571        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;572    	#endif
;;;573    
;;;574        /* Waiting for external XTAL clock ready */
;;;575        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;576    
;;;577        /* Set core clock as PLL_CLOCK from PLL */
;;;578        CLK_SetCoreClock(PLL_CLOCK);
000022  4821              LDR      r0,|L13.168|
000024  f7fffffe          BL       CLK_SetCoreClock
;;;579    
;;;580        /* Enable UART module clock */
;;;581        CLK_EnableModuleClock(UART0_MODULE);
000028  4c20              LDR      r4,|L13.172|
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       CLK_EnableModuleClock
;;;582    
;;;583        /* Enable IP clock */
;;;584        CLK_EnableModuleClock(USCI0_MODULE);
000030  481f              LDR      r0,|L13.176|
000032  f7fffffe          BL       CLK_EnableModuleClock
;;;585    
;;;586        /* Enable I2C0 clock */
;;;587        CLK_EnableModuleClock(I2C0_MODULE);
000036  481f              LDR      r0,|L13.180|
000038  f7fffffe          BL       CLK_EnableModuleClock
;;;588    
;;;589        /* Enable I2C1 clock */
;;;590        CLK_EnableModuleClock(I2C1_MODULE);
00003c  481d              LDR      r0,|L13.180|
00003e  1c40              ADDS     r0,r0,#1
000040  f7fffffe          BL       CLK_EnableModuleClock
;;;591    
;;;592        /* Select UART module clock source */
;;;593    	#if defined (ENABLE_NUC125)
;;;594        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UARTSEL_HIRC_DIV2, CLK_CLKDIV0_UART(1));
000044  2103              MOVS     r1,#3
000046  2200              MOVS     r2,#0
000048  0609              LSLS     r1,r1,#24
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       CLK_SetModuleClock
;;;595    	#elif defined (ENABLE_NUC126)	
;;;596        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UARTSEL_HIRC, CLK_CLKDIV0_UART(1));
;;;597    	#endif
;;;598    
;;;599        /* Update System Core Clock */
;;;600        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock and cyclesPerUs automatically. */
;;;601        SystemCoreClockUpdate();
000050  f7fffffe          BL       SystemCoreClockUpdate
;;;602    
;;;603        /*---------------------------------------------------------------------------------------------------------*/
;;;604        /* Init I/O Multi-function                                                                                 */
;;;605        /*---------------------------------------------------------------------------------------------------------*/
;;;606    
;;;607    	#if defined (ENABLE_NUC125)
;;;608        /* Set PB multi-function pins for UART0 RXD(PB.0) and TXD(PB.1) */
;;;609        SYS->GPB_MFPL = (SYS->GPB_MFPL & (~SYS_GPB_MFPL_PB0MFP_Msk)) | SYS_GPB_MFPL_PB0MFP_UART0_RXD;
000054  2005              MOVS     r0,#5
000056  0700              LSLS     r0,r0,#28
000058  6b81              LDR      r1,[r0,#0x38]
00005a  0909              LSRS     r1,r1,#4
00005c  0109              LSLS     r1,r1,#4
00005e  1c49              ADDS     r1,r1,#1
000060  6381              STR      r1,[r0,#0x38]
;;;610        SYS->GPB_MFPL = (SYS->GPB_MFPL & (~SYS_GPB_MFPL_PB1MFP_Msk)) | SYS_GPB_MFPL_PB1MFP_UART0_TXD;
000062  6b81              LDR      r1,[r0,#0x38]
000064  22f0              MOVS     r2,#0xf0
000066  4391              BICS     r1,r1,r2
000068  3110              ADDS     r1,r1,#0x10
00006a  6381              STR      r1,[r0,#0x38]
;;;611    
;;;612        /* Set PC multi-function pins for UI2C SDA and SCL */
;;;613        SYS->GPC_MFPL &= ~(SYS_GPC_MFPL_PC3MFP_Msk | SYS_GPC_MFPL_PC0MFP_Msk);
00006c  4912              LDR      r1,|L13.184|
00006e  680a              LDR      r2,[r1,#0]
000070  4b12              LDR      r3,|L13.188|
000072  401a              ANDS     r2,r2,r3
000074  600a              STR      r2,[r1,#0]
;;;614        SYS->GPC_MFPL |= (SYS_GPC_MFPL_PC3MFP_USCI0_DAT0 | SYS_GPC_MFPL_PC0MFP_USCI0_CLK);
000076  680a              LDR      r2,[r1,#0]
000078  4b11              LDR      r3,|L13.192|
00007a  431a              ORRS     r2,r2,r3
00007c  600a              STR      r2,[r1,#0]
;;;615    
;;;616        /* Set PC multi-function pins for I2C0 SDA and SCL */
;;;617        SYS->GPC_MFPH &= ~(SYS_GPC_MFPH_PC11MFP_Msk | SYS_GPC_MFPH_PC12MFP_Msk);
00007e  684a              LDR      r2,[r1,#4]
000080  23ff              MOVS     r3,#0xff
000082  031b              LSLS     r3,r3,#12
000084  439a              BICS     r2,r2,r3
000086  604a              STR      r2,[r1,#4]
;;;618        SYS->GPC_MFPH |= (SYS_GPC_MFPH_PC11MFP_I2C0_SDA | SYS_GPC_MFPH_PC12MFP_I2C0_SCL);
000088  684a              LDR      r2,[r1,#4]
00008a  2333              MOVS     r3,#0x33
00008c  035b              LSLS     r3,r3,#13
00008e  431a              ORRS     r2,r2,r3
000090  604a              STR      r2,[r1,#4]
;;;619    
;;;620        /* Set PA multi-function pins for I2C1 SDA and SCL */
;;;621        SYS->GPA_MFPH &= ~(SYS_GPA_MFPH_PA10MFP_Msk | SYS_GPA_MFPH_PA11MFP_Msk);
000092  6b41              LDR      r1,[r0,#0x34]
000094  22ff              MOVS     r2,#0xff
000096  0212              LSLS     r2,r2,#8
000098  4391              BICS     r1,r1,r2
00009a  6341              STR      r1,[r0,#0x34]
;;;622        SYS->GPA_MFPH |= (SYS_GPA_MFPH_PA10MFP_I2C1_SDA | SYS_GPA_MFPH_PA11MFP_I2C1_SCL);
00009c  6b41              LDR      r1,[r0,#0x34]
00009e  2211              MOVS     r2,#0x11
0000a0  0212              LSLS     r2,r2,#8
0000a2  4311              ORRS     r1,r1,r2
0000a4  6341              STR      r1,[r0,#0x34]
;;;623    	#elif defined (ENABLE_NUC126)	
;;;624        /* Set PD multi-function pins for UART0 RXD and TXD */
;;;625        SYS->GPD_MFPL &= ~(SYS_GPD_MFPL_PD0MFP_Msk | SYS_GPD_MFPL_PD1MFP_Msk);
;;;626        SYS->GPD_MFPL |= SYS_GPD_MFPL_PD0MFP_UART0_RXD | SYS_GPD_MFPL_PD1MFP_UART0_TXD;
;;;627    
;;;628        /* Set PC multi-function pins for UI2C0_SDA(PC.5) and UI2C0_SCL(PC.4) */
;;;629        SYS->GPC_MFPL &= ~(SYS_GPC_MFPL_PC5MFP_Msk | SYS_GPC_MFPL_PC4MFP_Msk);
;;;630        SYS->GPC_MFPL |= (SYS_GPC_MFPL_PC5MFP_USCI0_DAT0 | SYS_GPC_MFPL_PC4MFP_USCI0_CLK);
;;;631    
;;;632    
;;;633        /* Set I2C0 multi-function pins */
;;;634        SYS->GPA_MFPH = (SYS->GPA_MFPH & ~(SYS_GPA_MFPH_PA9MFP_Msk | SYS_GPA_MFPH_PA8MFP_Msk)) |
;;;635                        (SYS_GPA_MFPH_PA9MFP_I2C1_SDA | SYS_GPA_MFPH_PA8MFP_I2C1_SCL);
;;;636    
;;;637        /* Set I2C1 multi-function pins */
;;;638        SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA2MFP_Msk | SYS_GPA_MFPL_PA3MFP_Msk)) |
;;;639                        (SYS_GPA_MFPL_PA2MFP_I2C0_SDA | SYS_GPA_MFPL_PA3MFP_I2C0_SCL);
;;;640    	#endif
;;;641    	
;;;642    }
0000a6  bd10              POP      {r4,pc}
;;;643    void I2C0_Init(void)
                          ENDP

                  |L13.168|
                          DCD      0x02faf080
                  |L13.172|
                          DCD      0x57803d10
                  |L13.176|
                          DCD      0x80000008
                  |L13.180|
                          DCD      0x40000008
                  |L13.184|
                          DCD      0x50000040
                  |L13.188|
                          DCD      0xffff0ff0
                  |L13.192|
                          DCD      0x00007007

                          AREA ||i.UI2C0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UI2C0_Init PROC
;;;701    
;;;702    void UI2C0_Init(uint32_t u32ClkSpeed)
000000  b510              PUSH     {r4,lr}
;;;703    {
;;;704        /* Open USCI_I2C0 and set clock to 100k */
;;;705        UI2C_Open(UI2C0, u32ClkSpeed);
000002  4c16              LDR      r4,|L14.92|
000004  4601              MOV      r1,r0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UI2C_Open
;;;706    
;;;707        /* Get USCI_I2C0 Bus Clock */
;;;708        printf("UI2C0 clock %d Hz\n", UI2C_GetBusClockFreq(UI2C0));
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       UI2C_GetBusClockFreq
000012  4601              MOV      r1,r0
000014  a012              ADR      r0,|L14.96|
000016  f7fffffe          BL       __2printf
;;;709    
;;;710        /* Set USCI_I2C0 Slave Addresses */
;;;711        UI2C_SetSlaveAddr(UI2C0, 0, 0x16, UI2C_GCMODE_DISABLE);   /* Slave Address : 0x16 */
00001a  2300              MOVS     r3,#0
00001c  2216              MOVS     r2,#0x16
00001e  4619              MOV      r1,r3
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       UI2C_SetSlaveAddr
;;;712        UI2C_SetSlaveAddr(UI2C0, 1, 0x36, UI2C_GCMODE_DISABLE);   /* Slave Address : 0x36 */
000026  2300              MOVS     r3,#0
000028  2236              MOVS     r2,#0x36
00002a  2101              MOVS     r1,#1
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       UI2C_SetSlaveAddr
;;;713    
;;;714        /* Set USCI_I2C0 Slave Addresses Mask */
;;;715        UI2C_SetSlaveAddrMask(UI2C0, 0, 0x04);                    /* Slave Address : 0x4 */
000032  2204              MOVS     r2,#4
000034  2100              MOVS     r1,#0
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       UI2C_SetSlaveAddrMask
;;;716        UI2C_SetSlaveAddrMask(UI2C0, 1, 0x02);                    /* Slave Address : 0x2 */
00003c  2202              MOVS     r2,#2
00003e  2101              MOVS     r1,#1
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       UI2C_SetSlaveAddrMask
;;;717    
;;;718        /* Enable UI2C0 protocol interrupt */
;;;719        UI2C_ENABLE_PROT_INT(UI2C0, (UI2C_PROTIEN_ACKIEN_Msk | UI2C_PROTIEN_NACKIEN_Msk | UI2C_PROTIEN_STORIEN_Msk | UI2C_PROTIEN_STARIEN_Msk));
000046  4805              LDR      r0,|L14.92|
000048  3040              ADDS     r0,r0,#0x40
00004a  6a01              LDR      r1,[r0,#0x20]
00004c  224e              MOVS     r2,#0x4e
00004e  4311              ORRS     r1,r1,r2
000050  6201              STR      r1,[r0,#0x20]
;;;720        NVIC_EnableIRQ(USCI_IRQn);
000052  2016              MOVS     r0,#0x16
000054  f7fffffe          BL       __NVIC_EnableIRQ
;;;721    
;;;722    }
000058  bd10              POP      {r4,pc}
;;;723    
                          ENDP

00005a  0000              DCW      0x0000
                  |L14.92|
                          DCD      0x40070000
                  |L14.96|
000060  55493243          DCB      "UI2C0 clock %d Hz\n",0
000064  3020636c
000068  6f636b20
00006c  25642048
000070  7a0a00  
000073  00                DCB      0

                          AREA ||i.UI2C_Init||, CODE, READONLY, ALIGN=2

                  UI2C_Init PROC
;;;966    
;;;967    void UI2C_Init(void)
000000  b510              PUSH     {r4,lr}
;;;968    {
;;;969        /* Init USCI_I2C0 */
;;;970        UI2C0_Init(100000);
000002  480b              LDR      r0,|L15.48|
000004  f7fffffe          BL       UI2C0_Init
;;;971    
;;;972        s_Event = SLAVE_ADDRESS_ACK;
000008  4a0a              LDR      r2,|L15.52|
00000a  2064              MOVS     r0,#0x64
00000c  72d0              STRB     r0,[r2,#0xb]
;;;973    
;;;974        UI2C0->PROTCTL |= (UI2C_PROTCTL_MONEN_Msk | UI2C_PROTCTL_SCLOUTEN_Msk);
00000e  480a              LDR      r0,|L15.56|
000010  69c1              LDR      r1,[r0,#0x1c]
000012  2303              MOVS     r3,#3
000014  021b              LSLS     r3,r3,#8
000016  4319              ORRS     r1,r1,r3
000018  61c1              STR      r1,[r0,#0x1c]
;;;975    
;;;976        UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_AA));
00001a  69c1              LDR      r1,[r0,#0x1c]
00001c  232e              MOVS     r3,#0x2e
00001e  4399              BICS     r1,r1,r3
000020  3122              ADDS     r1,r1,#0x22
000022  61c1              STR      r1,[r0,#0x1c]
;;;977    
;;;978        /* UI2C function to Slave receive/transmit data */
;;;979        s_UI2C0HandlerFn = UI2C_SlaveTRx_Monitor;
000024  4805              LDR      r0,|L15.60|
000026  6150              STR      r0,[r2,#0x14]  ; s_UI2C0HandlerFn
;;;980    
;;;981        printf("UI2C0 Monitor Mode is Running.\r\n");
000028  a005              ADR      r0,|L15.64|
00002a  f7fffffe          BL       __2printf
;;;982    }
00002e  bd10              POP      {r4,pc}
;;;983    
                          ENDP

                  |L15.48|
                          DCD      0x000186a0
                  |L15.52|
                          DCD      ||.data||
                  |L15.56|
                          DCD      0x40070040
                  |L15.60|
                          DCD      UI2C_SlaveTRx_Monitor
                  |L15.64|
000040  55493243          DCB      "UI2C0 Monitor Mode is Running.\r\n",0
000044  30204d6f
000048  6e69746f
00004c  72204d6f
000050  64652069
000054  73205275
000058  6e6e696e
00005c  672e0d0a
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.UI2C_Monitor||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  UI2C_Monitor PROC
;;;931    
;;;932    int32_t UI2C_Monitor(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;933    {
;;;934        int32_t i32Err = 0;
;;;935        uint32_t u32Index;
;;;936    	
;;;937        g_u32ProtOn = 0;
000002  4816              LDR      r0,|L16.92|
000004  2600              MOVS     r6,#0
000006  6186              STR      r6,[r0,#0x18]  ; g_u32ProtOn
;;;938    
;;;939        i32Err = I2C0_Read_Write_Slave(0x16);
000008  2016              MOVS     r0,#0x16
00000a  f7fffffe          BL       I2C0_Read_Write_Slave
00000e  4607              MOV      r7,r0
;;;940    
;;;941        printf("Dump Monitor data: \r\n");
000010  a013              ADR      r0,|L16.96|
000012  f7fffffe          BL       __2printf
;;;942    
;;;943        for (u32Index = 0; u32Index < (I2C_DATA_MAX + 1); u32Index++)
000016  2400              MOVS     r4,#0
;;;944        {
;;;945            if (u32Index == 0)
;;;946            {
;;;947                printf("Monitor address: [0x%2X] \r\n", g_u8MonRxData[u32Index] >> 1);
000018  4d17              LDR      r5,|L16.120|
00001a  e008              B        |L16.46|
                  |L16.28|
00001c  2c00              CMP      r4,#0                 ;945
00001e  d006              BEQ      |L16.46|
;;;948            }
;;;949            else
;;;950            {
;;;951                printf("0x%2X , ", g_u8MonRxData[u32Index]);
000020  5d29              LDRB     r1,[r5,r4]
000022  a016              ADR      r0,|L16.124|
000024  f7fffffe          BL       __2printf
;;;952    	        if ((u32Index)%8 ==0)
000028  0760              LSLS     r0,r4,#29
00002a  d109              BNE      |L16.64|
00002c  e005              B        |L16.58|
                  |L16.46|
00002e  7828              LDRB     r0,[r5,#0]            ;947
000030  0841              LSRS     r1,r0,#1              ;947
000032  a015              ADR      r0,|L16.136|
000034  f7fffffe          BL       __2printf
000038  e002              B        |L16.64|
                  |L16.58|
;;;953    	        {
;;;954    	            printf("\r\n");
00003a  a01a              ADR      r0,|L16.164|
00003c  f7fffffe          BL       __2printf
                  |L16.64|
000040  1c64              ADDS     r4,r4,#1
000042  2c19              CMP      r4,#0x19              ;943
000044  d3ea              BCC      |L16.28|
;;;955    	        }			
;;;956            }
;;;957        }
;;;958    
;;;959        printf("\r\n");
000046  a017              ADR      r0,|L16.164|
000048  f7fffffe          BL       __2printf
;;;960    
;;;961        for (u32Index = 0; u32Index < I2C_DATA_MAX; u32Index++)
00004c  2000              MOVS     r0,#0
                  |L16.78|
;;;962            g_u8MonRxData[u32Index] = 0;
00004e  542e              STRB     r6,[r5,r0]
000050  1c40              ADDS     r0,r0,#1
000052  2818              CMP      r0,#0x18              ;961
000054  d3fb              BCC      |L16.78|
;;;963    
;;;964        return i32Err;
000056  4638              MOV      r0,r7
;;;965    }
000058  bdf8              POP      {r3-r7,pc}
;;;966    
                          ENDP

00005a  0000              DCW      0x0000
                  |L16.92|
                          DCD      ||.data||
                  |L16.96|
000060  44756d70          DCB      "Dump Monitor data: \r\n",0
000064  204d6f6e
000068  69746f72
00006c  20646174
000070  613a200d
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0
                  |L16.120|
                          DCD      ||.bss||
                  |L16.124|
00007c  30782532          DCB      "0x%2X , ",0
000080  58202c20
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L16.136|
000088  4d6f6e69          DCB      "Monitor address: [0x%2X] \r\n",0
00008c  746f7220
000090  61646472
000094  6573733a
000098  205b3078
00009c  2532585d
0000a0  200d0a00
                  |L16.164|
0000a4  0d0a00            DCB      "\r\n",0
0000a7  00                DCB      0

                          AREA ||i.UI2C_SlaveTRx_Monitor||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  UI2C_SlaveTRx_Monitor PROC
;;;857    /*---------------------------------------------------------------------------------------------------------*/
;;;858    void UI2C_SlaveTRx_Monitor(uint32_t u32Status)
000000  b5f8              PUSH     {r3-r7,lr}
;;;859    {
;;;860        uint8_t u8Rxdata;
;;;861    
;;;862        if((u32Status & UI2C_PROTSTS_STARIF_Msk) == UI2C_PROTSTS_STARIF_Msk)
000002  05c1              LSLS     r1,r0,#23
;;;863        {
;;;864            /* Clear START INT Flag */
;;;865            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_STARIF_Msk);
;;;866    
;;;867            if (g_u32ProtOn == 0)
;;;868            {
;;;869                g_u32ProtOn = 1;
;;;870            }
;;;871    
;;;872            s_Event = SLAVE_ADDRESS_ACK;
000004  2664              MOVS     r6,#0x64
;;;873            UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_AA));
000006  232e              MOVS     r3,#0x2e
000008  4d2b              LDR      r5,|L17.184|
00000a  4a2c              LDR      r2,|L17.188|
00000c  2900              CMP      r1,#0                 ;862
00000e  da08              BGE      |L17.34|
000010  15a8              ASRS     r0,r5,#22             ;865
000012  6268              STR      r0,[r5,#0x24]         ;865
000014  6990              LDR      r0,[r2,#0x18]         ;867  ; g_u32ProtOn
000016  2800              CMP      r0,#0                 ;867
000018  d101              BNE      |L17.30|
00001a  2001              MOVS     r0,#1                 ;869
00001c  e049              B        |L17.178|
                  |L17.30|
00001e  72d6              STRB     r6,[r2,#0xb]          ;872
000020  e036              B        |L17.144|
                  |L17.34|
;;;874        }
;;;875        else if((u32Status & UI2C_PROTSTS_ACKIF_Msk) == UI2C_PROTSTS_ACKIF_Msk)
;;;876        {
;;;877            /* Clear ACK INT Flag */
;;;878            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_ACKIF_Msk);
;;;879    
;;;880            if(s_Event==SLAVE_ADDRESS_ACK)
;;;881            {
;;;882                if((UI2C0->PROTSTS & UI2C_PROTSTS_SLAREAD_Msk) == UI2C_PROTSTS_SLAREAD_Msk)
;;;883                {
;;;884                    u8Rxdata = (uint8_t)UI2C_GET_DATA(UI2C0);
000022  4927              LDR      r1,|L17.192|
;;;885                    g_u8MonRxData[g_u8MonDataCnt++] = u8Rxdata;
000024  4c27              LDR      r4,|L17.196|
000026  0487              LSLS     r7,r0,#18             ;875
000028  d537              BPL      |L17.154|
00002a  2001              MOVS     r0,#1                 ;878
00002c  0340              LSLS     r0,r0,#13             ;878
00002e  6268              STR      r0,[r5,#0x24]         ;878
000030  7ad0              LDRB     r0,[r2,#0xb]          ;880  ; s_Event
000032  2864              CMP      r0,#0x64              ;880
000034  d003              BEQ      |L17.62|
;;;886                    s_Event = SLAVE_SEND_DATA;				
;;;887                }
;;;888                else
;;;889                {
;;;890                    u8Rxdata = (uint8_t)UI2C_GET_DATA(UI2C0);;
;;;891                    g_u8MonRxData[g_u8MonDataCnt++] = u8Rxdata;
;;;892                    s_Event = SLAVE_GET_DATA;				
;;;893                }
;;;894    
;;;895                if (((u8Rxdata >> 1) != (UI2C0->DEVADDR0 & 0xFF)) && ((u8Rxdata >> 1) != (UI2C0->DEVADDR1 & 0xFF)))
;;;896                {
;;;897                    /* Check Receive Adddress not match */
;;;898                    printf("\n[Error]Receive address(0x%x) not match!\n", u8Rxdata);
;;;899    
;;;900                    while (1);
;;;901                }
;;;902    
;;;903                s_Event=SLAVE_GET_DATA;
;;;904            }
;;;905            else if(s_Event==SLAVE_GET_DATA)
000036  7ad0              LDRB     r0,[r2,#0xb]  ; s_Event
000038  2867              CMP      r0,#0x67
00003a  d023              BEQ      |L17.132|
00003c  e028              B        |L17.144|
                  |L17.62|
00003e  6a68              LDR      r0,[r5,#0x24]         ;882
000040  2667              MOVS     r6,#0x67              ;892
000042  0400              LSLS     r0,r0,#16             ;882
000044  2800              CMP      r0,#0                 ;882
000046  6b48              LDR      r0,[r1,#0x34]         ;890
000048  da08              BGE      |L17.92|
00004a  b2c1              UXTB     r1,r0                 ;884
00004c  7850              LDRB     r0,[r2,#1]            ;885  ; g_u8MonDataCnt
00004e  1824              ADDS     r4,r4,r0              ;885
000050  1c40              ADDS     r0,r0,#1              ;885
000052  7050              STRB     r0,[r2,#1]            ;885
000054  7021              STRB     r1,[r4,#0]            ;885
000056  2068              MOVS     r0,#0x68              ;886
000058  72d0              STRB     r0,[r2,#0xb]          ;886
00005a  e006              B        |L17.106|
                  |L17.92|
00005c  b2c1              UXTB     r1,r0                 ;890
00005e  7850              LDRB     r0,[r2,#1]            ;891  ; g_u8MonDataCnt
000060  1824              ADDS     r4,r4,r0              ;891
000062  1c40              ADDS     r0,r0,#1              ;891
000064  7050              STRB     r0,[r2,#1]            ;891
000066  7021              STRB     r1,[r4,#0]            ;891
000068  72d6              STRB     r6,[r2,#0xb]          ;892
                  |L17.106|
00006a  686c              LDR      r4,[r5,#4]            ;895
00006c  0848              LSRS     r0,r1,#1              ;895
00006e  b2e4              UXTB     r4,r4                 ;895
000070  42a0              CMP      r0,r4                 ;895
000072  d0d4              BEQ      |L17.30|
000074  68ac              LDR      r4,[r5,#8]            ;895
000076  b2e4              UXTB     r4,r4                 ;895
000078  42a0              CMP      r0,r4                 ;895
00007a  d0d0              BEQ      |L17.30|
00007c  a012              ADR      r0,|L17.200|
00007e  f7fffffe          BL       __2printf
                  |L17.130|
000082  e7fe              B        |L17.130|
                  |L17.132|
;;;906            {
;;;907                u8Rxdata = (uint8_t)UI2C_GET_DATA(UI2C0);
000084  6b49              LDR      r1,[r1,#0x34]
;;;908                g_u8MonRxData[g_u8MonDataCnt++] = u8Rxdata;
000086  7850              LDRB     r0,[r2,#1]  ; g_u8MonDataCnt
000088  1824              ADDS     r4,r4,r0
00008a  1c40              ADDS     r0,r0,#1
00008c  7050              STRB     r0,[r2,#1]
00008e  7021              STRB     r1,[r4,#0]
                  |L17.144|
;;;909            }
;;;910    
;;;911            UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_AA));
000090  69e8              LDR      r0,[r5,#0x1c]
000092  4398              BICS     r0,r0,r3
000094  3022              ADDS     r0,r0,#0x22
000096  61e8              STR      r0,[r5,#0x1c]
                  |L17.152|
;;;912        }
;;;913        else if((u32Status & UI2C_PROTSTS_NACKIF_Msk) == UI2C_PROTSTS_NACKIF_Msk)
;;;914        {
;;;915            /* Clear NACK INT Flag */
;;;916            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_NACKIF_Msk);
;;;917    
;;;918            u8Rxdata = (uint8_t)UI2C_GET_DATA(UI2C0);
;;;919            g_u8MonRxData[g_u8MonDataCnt++] = u8Rxdata;
;;;920            UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_AA));
;;;921        }
;;;922        else if((u32Status & UI2C_PROTSTS_STORIF_Msk) == UI2C_PROTSTS_STORIF_Msk)
;;;923        {
;;;924            /* Clear STO INT Flag */
;;;925            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_STORIF_Msk);
;;;926            g_u32ProtOn = 0;
;;;927            s_Event = SLAVE_ADDRESS_ACK;
;;;928            UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_AA));
;;;929        }
;;;930    }
000098  bdf8              POP      {r3-r7,pc}
                  |L17.154|
00009a  0547              LSLS     r7,r0,#21             ;913
00009c  d503              BPL      |L17.166|
00009e  2001              MOVS     r0,#1                 ;916
0000a0  0280              LSLS     r0,r0,#10             ;916
0000a2  6268              STR      r0,[r5,#0x24]         ;916
0000a4  e7ee              B        |L17.132|
                  |L17.166|
0000a6  0580              LSLS     r0,r0,#22             ;922
0000a8  d5f6              BPL      |L17.152|
0000aa  2001              MOVS     r0,#1                 ;925
0000ac  0240              LSLS     r0,r0,#9              ;925
0000ae  6268              STR      r0,[r5,#0x24]         ;925
0000b0  2000              MOVS     r0,#0                 ;926
                  |L17.178|
0000b2  6190              STR      r0,[r2,#0x18]         ;926  ; g_u32ProtOn
0000b4  e7b3              B        |L17.30|
;;;931    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L17.184|
                          DCD      0x40070040
                  |L17.188|
                          DCD      ||.data||
                  |L17.192|
                          DCD      0x40070000
                  |L17.196|
                          DCD      ||.bss||
                  |L17.200|
0000c8  0a5b4572          DCB      "\n[Error]Receive address(0x%x) not match!\n",0
0000cc  726f725d
0000d0  52656365
0000d4  69766520
0000d8  61646472
0000dc  65737328
0000e0  30782578
0000e4  29206e6f
0000e8  74206d61
0000ec  74636821
0000f0  0a00    
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.USCI_IRQHandler||, CODE, READONLY, ALIGN=2

                  USCI_IRQHandler PROC
;;;151    /*---------------------------------------------------------------------------------------------------------*/
;;;152    void USCI_IRQHandler(void)
000000  4804              LDR      r0,|L18.20|
;;;153    {
;;;154        uint32_t u32Status;
;;;155    
;;;156        //UI2C0 Interrupt
;;;157        u32Status = UI2C_GET_PROT_STATUS(UI2C0);
000002  6a40              LDR      r0,[r0,#0x24]
;;;158    
;;;159        if (s_UI2C0HandlerFn != NULL)
000004  4904              LDR      r1,|L18.24|
000006  694a              LDR      r2,[r1,#0x14]  ; s_UI2C0HandlerFn
000008  2a00              CMP      r2,#0
00000a  d001              BEQ      |L18.16|
;;;160        {
;;;161            s_UI2C0HandlerFn(u32Status);
00000c  6949              LDR      r1,[r1,#0x14]  ; s_UI2C0HandlerFn
00000e  4708              BX       r1
                  |L18.16|
;;;162        }
;;;163    }
000010  4770              BX       lr
;;;164    
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x40070040
                  |L18.24|
                          DCD      ||.data||

                          AREA ||i.__NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  __NVIC_DisableIRQ PROC
;;;650     */
;;;651    __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;652    {
000002  db09              BLT      |L19.24|
;;;653      if ((int32_t)(IRQn) >= 0)
;;;654      {
;;;655        NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  06c1              LSLS     r1,r0,#27
000006  0ec9              LSRS     r1,r1,#27
000008  2001              MOVS     r0,#1
00000a  4088              LSLS     r0,r0,r1
00000c  4903              LDR      r1,|L19.28|
00000e  6008              STR      r0,[r1,#0]
;;;656        __DSB();
000010  f3bf8f4f          DSB      
;;;657        __ISB();
000014  f3bf8f6f          ISB      
                  |L19.24|
;;;658      }
;;;659    }
000018  4770              BX       lr
;;;660    
                          ENDP

00001a  0000              DCW      0x0000
                  |L19.28|
                          DCD      0xe000e180

                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  __NVIC_EnableIRQ PROC
;;;614     */
;;;615    __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;616    {
000002  db05              BLT      |L20.16|
;;;617      if ((int32_t)(IRQn) >= 0)
;;;618      {
;;;619        NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  06c1              LSLS     r1,r0,#27
000006  0ec9              LSRS     r1,r1,#27
000008  2001              MOVS     r0,#1
00000a  4088              LSLS     r0,r0,r1
00000c  4901              LDR      r1,|L20.20|
00000e  6008              STR      r0,[r1,#0]
                  |L20.16|
;;;620      }
;;;621    }
000010  4770              BX       lr
;;;622    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0xe000e100

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;983    
;;;984    int main()
000000  f7fffffe          BL       SYS_Init
;;;985    {
;;;986        uint32_t i;
;;;987    
;;;988        SYS_Init();
;;;989    
;;;990        /* Init UART0 to 115200-8n1 for print message */
;;;991        UART_Open(UART0, 115200);
000004  21e1              MOVS     r1,#0xe1
000006  0249              LSLS     r1,r1,#9
000008  4819              LDR      r0,|L21.112|
00000a  f7fffffe          BL       UART_Open
;;;992    
;;;993    //    printf("+-------------------------------------------------------+\n");
;;;994    //    printf("|  USCI_I2C Driver Sample Code for Monitor Mode         |\n");
;;;995    //    printf("|  7-bit Monitor mode test                              |\n");
;;;996    //    printf("|  I2C0(Master)  <----> UI2C0(Monitor) & I2C1(Slave)    |\n");
;;;997    //    printf("+-------------------------------------------------------+\n");
;;;998    
;;;999    //    printf("\n");
;;;1000   //    printf("Configure UI2C0 as a monitor mode.\n");
;;;1001   //    printf("The I/O connection for UI2C0:\n");
;;;1002   //    printf("UI2C0_SDA(PC.5), UI2C0_SCL(PC.4)\n");
;;;1003   //    printf("\n");
;;;1004   //    printf("Configure I2C0 as Master, and I2C1 as a slave.\n");
;;;1005   //    printf("The I/O connection I2C0 to I2C1:\n");
;;;1006   //    printf("I2C1_SDA(PA.9), I2C1_SCL(PA.8)\n");
;;;1007   //    printf("I2C0_SDA(PA.2), I2C0_SCL(PA.3)\r\n");
;;;1008   	
;;;1009       /* Init UI2C0 */
;;;1010       UI2C_Init();
00000e  f7fffffe          BL       UI2C_Init
;;;1011   
;;;1012       /* Init I2C0 */
;;;1013       I2C0_Init();
000012  f7fffffe          BL       I2C0_Init
;;;1014   
;;;1015       /* Init I2C1 */
;;;1016       I2C1_Init();
000016  f7fffffe          BL       I2C1_Init
;;;1017   
;;;1018       /* I2C1 enter non address SLV mode */
;;;1019       I2C_SET_CONTROL_REG(I2C1, I2C_CTL_SI_AA);
00001a  4816              LDR      r0,|L21.116|
00001c  6801              LDR      r1,[r0,#0]
00001e  223c              MOVS     r2,#0x3c
000020  4391              BICS     r1,r1,r2
000022  310c              ADDS     r1,r1,#0xc
000024  6001              STR      r1,[r0,#0]
;;;1020   
;;;1021       for(i = 0; i < 0x100; i++)
000026  2000              MOVS     r0,#0
;;;1022       {
;;;1023           g_au8SlvData[i] = 0;
000028  4a13              LDR      r2,|L21.120|
00002a  4601              MOV      r1,r0                 ;1021
                  |L21.44|
00002c  5411              STRB     r1,[r2,r0]
00002e  1c40              ADDS     r0,r0,#1
000030  28ff              CMP      r0,#0xff              ;1021
000032  d9fb              BLS      |L21.44|
;;;1024       }
;;;1025   
;;;1026       /* I2C1 function to Slave receive/transmit data */
;;;1027       s_I2C1HandlerFn = I2C_SlaveTRx;
000034  4c12              LDR      r4,|L21.128|
000036  4811              LDR      r0,|L21.124|
000038  6120              STR      r0,[r4,#0x10]  ; s_I2C1HandlerFn
;;;1028   
;;;1029       printf("\r\n");
00003a  a012              ADR      r0,|L21.132|
00003c  f7fffffe          BL       __2printf
;;;1030       printf("I2C1 Slave Mode is Running\r\n");
000040  a011              ADR      r0,|L21.136|
000042  f7fffffe          BL       __2printf
                  |L21.70|
;;;1031   
;;;1032       while (1)
;;;1033       {
;;;1034           printf("Monitor test ....\r\n");
000046  a018              ADR      r0,|L21.168|
000048  f7fffffe          BL       __2printf
;;;1035           UI2C_Monitor();
00004c  f7fffffe          BL       UI2C_Monitor
;;;1036   
;;;1037           printf("Press any key to continue (increase TX data idx 1)\r\n");
000050  a01a              ADR      r0,|L21.188|
000052  f7fffffe          BL       __2printf
;;;1038           getchar();
000056  4827              LDR      r0,|L21.244|
000058  f7fffffe          BL       getc
;;;1039   		g_u8test_data = (g_u8test_data >= 0xFF) ? (0x10) : (g_u8test_data + 1);
00005c  78a0              LDRB     r0,[r4,#2]  ; g_u8test_data
00005e  28ff              CMP      r0,#0xff
000060  d301              BCC      |L21.102|
000062  2010              MOVS     r0,#0x10
000064  e001              B        |L21.106|
                  |L21.102|
000066  78a0              LDRB     r0,[r4,#2]  ; g_u8test_data
000068  1c40              ADDS     r0,r0,#1
                  |L21.106|
00006a  70a0              STRB     r0,[r4,#2]
00006c  e7eb              B        |L21.70|
;;;1040   
;;;1041       }
;;;1042   }
;;;1043   
                          ENDP

00006e  0000              DCW      0x0000
                  |L21.112|
                          DCD      0x40050000
                  |L21.116|
                          DCD      0x40120000
                  |L21.120|
                          DCD      ||.bss||+0x7a
                  |L21.124|
                          DCD      I2C_SlaveTRx
                  |L21.128|
                          DCD      ||.data||
                  |L21.132|
000084  0d0a00            DCB      "\r\n",0
000087  00                DCB      0
                  |L21.136|
000088  49324331          DCB      "I2C1 Slave Mode is Running\r\n",0
00008c  20536c61
000090  7665204d
000094  6f646520
000098  69732052
00009c  756e6e69
0000a0  6e670d0a
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L21.168|
0000a8  4d6f6e69          DCB      "Monitor test ....\r\n",0
0000ac  746f7220
0000b0  74657374
0000b4  202e2e2e
0000b8  2e0d0a00
                  |L21.188|
0000bc  50726573          DCB      "Press any key to continue (increase TX data idx 1)\r\n",0
0000c0  7320616e
0000c4  79206b65
0000c8  7920746f
0000cc  20636f6e
0000d0  74696e75
0000d4  65202869
0000d8  6e637265
0000dc  61736520
0000e0  54582064
0000e4  61746120
0000e8  69647820
0000ec  31290d0a
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L21.244|
                          DCD      __stdin

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_u8MonRxData
                          %        50
                  g_u8ToMasterData
                          %        24
                  g_u8FromMasterData
                          %        24
                  g_au8MstTxData
                          %        24
                  g_au8SlvData
                          %        256

                          AREA ||area_number.24||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.bss||
                  g_au8SlvRxData
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8MstEndFlag
000000  00                DCB      0x00
                  g_u8MonDataCnt
000001  00                DCB      0x00
                  g_u8test_data
000002  10                DCB      0x10
                  g_u8DataLen_s
000003  00                DCB      0x00
                  g_u8ToMasterLen
000004  00                DCB      0x00
                  g_u8FromMasterLen
000005  00                DCB      0x00
                  slave_register_addr
000006  00                DCB      0x00
                  g_u8temporary
000007  00                DCB      0x00
                  ||cnt||
000008  00                DCB      0x00
                  g_u8DeviceAddr
000009  00                DCB      0x00
                  g_u8MstDataLen
00000a  00                DCB      0x00
                  s_Event
00000b  00                DCB      0x00
                  s_I2C0HandlerFn
                          DCD      0x00000000
                  s_I2C1HandlerFn
                          DCD      0x00000000
                  s_UI2C0HandlerFn
                          DCD      0x00000000
                  g_u32ProtOn
                          DCD      0x00000000
                  slave_buff_addr
                          DCD      0x00000000

                          AREA ||area_number.27||, DATA, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.data||
                  g_u8RxDataTmp
000000  00                DCB      0x00

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  g_u8MstRxData
000000  00                DCB      0x00

                          AREA ||area_number.29||, DATA, ALIGN=0

                          EXPORTAS ||area_number.29||, ||.data||
                  g_u8SlvDataLen
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_9fb483c8____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_9fb483c8____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_9fb483c8____REVSH|
#line 479
|__asm___6_main_c_9fb483c8____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
