; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c.crf ..\..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;87       */
;;;88     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;89     {
;;;90         i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;91     }
000008  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;59     
;;;60     void I2C_Close(I2C_T *i2c)
000000  4a0b              LDR      r2,|L2.48|
;;;61     {
;;;62         /* Reset I2C controller */
;;;63         if ((uint32_t)i2c == I2C0_BASE)
;;;64         {
;;;65             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
000006  4290              CMP      r0,r2                 ;63
000008  d102              BNE      |L2.16|
00000a  68cb              LDR      r3,[r1,#0xc]
00000c  1582              ASRS     r2,r0,#22
;;;66             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
00000e  e004              B        |L2.26|
                  |L2.16|
;;;67         }
;;;68         else if ((uint32_t)i2c == I2C1_BASE)
000010  4a08              LDR      r2,|L2.52|
000012  4290              CMP      r0,r2
000014  d106              BNE      |L2.36|
;;;69         {
;;;70             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
000016  68cb              LDR      r3,[r1,#0xc]
000018  1542              ASRS     r2,r0,#21
                  |L2.26|
00001a  4313              ORRS     r3,r3,r2
00001c  60cb              STR      r3,[r1,#0xc]
;;;71             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
00001e  68cb              LDR      r3,[r1,#0xc]
000020  4393              BICS     r3,r3,r2
000022  60cb              STR      r3,[r1,#0xc]
                  |L2.36|
;;;72         }
;;;73     
;;;74         /* Disable I2C */
;;;75         i2c->CTL &= ~I2C_CTL_I2CEN_Msk;
000024  6801              LDR      r1,[r0,#0]
000026  2240              MOVS     r2,#0x40
000028  4391              BICS     r1,r1,r2
00002a  6001              STR      r1,[r0,#0]
;;;76     }
00002c  4770              BX       lr
;;;77     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40020000
                  |L2.52|
                          DCD      0x40120000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;135      */
;;;136    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;137    {
;;;138        i2c->CTL &= ~I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;139    }
000008  4770              BX       lr
;;;140    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;352     */
;;;353    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;354    {
;;;355        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;356    }
000008  4770              BX       lr
;;;357    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;382     */
;;;383    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;384    {
;;;385        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;386    }
000008  4770              BX       lr
;;;387    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;150      */
;;;151    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;152    {
;;;153        i2c->CTL |= I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;154    }
000008  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;332     */
;;;333    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;334    {
;;;335        if (u8LongTimeout)
000002  2900              CMP      r1,#0
;;;336            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;337        else
;;;338            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;336
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;339    
;;;340        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;341    }
000018  4770              BX       lr
;;;342    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;367     */
;;;368    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;369    {
;;;370        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;371    }
000008  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;164     */
;;;165    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167        uint32_t u32Divider = i2c->CLKDIV;
000002  6900              LDR      r0,[r0,#0x10]
;;;168    
;;;169        return (SystemCoreClock / ((u32Divider + 1) << 2));
000004  0081              LSLS     r1,r0,#2
000006  4803              LDR      r0,|L9.20|
000008  1d09              ADDS     r1,r1,#4
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f7fffffe          BL       __aeabi_uidivmod
;;;170    }
000010  bd10              POP      {r4,pc}
;;;171    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;228     */
;;;229    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;230    {
;;;231        return (i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;232    }
000004  4770              BX       lr
;;;233    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;200     */
;;;201    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;202    {
;;;203        return ((i2c->CTL & I2C_CTL_SI_Msk) == I2C_CTL_SI_Msk ? 1 : 0);
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;204    }
000006  4770              BX       lr
;;;205    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;214     */
;;;215    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;216    {
;;;217        return (i2c->STATUS);
;;;218    }
000002  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;35       */
;;;36     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
;;;38         uint32_t u32Div;
;;;39     
;;;40         u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000002  4d0c              LDR      r5,|L13.52|
000004  4604              MOV      r4,r0                 ;37
000006  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
000008  220a              MOVS     r2,#0xa
00000a  0089              LSLS     r1,r1,#2
00000c  4350              MULS     r0,r2,r0
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  210a              MOVS     r1,#0xa
000014  1d40              ADDS     r0,r0,#5
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1e40              SUBS     r0,r0,#1
;;;41         i2c->CLKDIV = u32Div;
00001c  6120              STR      r0,[r4,#0x10]
;;;42     
;;;43         /* Enable I2C */
;;;44         i2c->CTL |= I2C_CTL_I2CEN_Msk;
00001e  6821              LDR      r1,[r4,#0]
000020  2240              MOVS     r2,#0x40
000022  4311              ORRS     r1,r1,r2
000024  6021              STR      r1,[r4,#0]
;;;45     
;;;46         return (SystemCoreClock / ((u32Div + 1) << 2));
000026  0081              LSLS     r1,r0,#2
000028  1d09              ADDS     r1,r1,#4
00002a  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;47     }
000030  bd70              POP      {r4-r6,pc}
;;;48     
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;813      */
;;;814    uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;815    {
;;;816        uint8_t u8Xfering = 1, u8Err = 0, u8rData = 0, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  2300              MOVS     r3,#0
;;;817    
;;;818        I2C_START(i2c);                                                /* Send START */
000006  6802              LDR      r2,[r0,#0]
000008  461c              MOV      r4,r3                 ;816
00000a  2628              MOVS     r6,#0x28
00000c  4332              ORRS     r2,r2,r6
00000e  6002              STR      r2,[r0,#0]
;;;819    
;;;820        while (u8Xfering && (u8Err == 0))
;;;821        {
;;;822            I2C_WAIT_READY(i2c);
;;;823    
;;;824            switch (I2C_GET_STATUS(i2c))
;;;825            {
;;;826            case 0x08:
;;;827                I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
;;;828                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;829                break;
;;;830    
;;;831            case 0x40:                                             /* Slave Address ACK */
;;;832                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;833                break;
;;;834    
;;;835            case 0x48:                                             /* Slave Address NACK */
;;;836                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;837                u8Err = 1;
;;;838                break;
;;;839    
;;;840            case 0x58:
;;;841                u8rData = (unsigned char) I2C_GET_DATA(i2c);         /* Receive Data */
;;;842                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;843                u8Xfering = 0;
;;;844                break;
;;;845    
;;;846            case 0x38:                                             /* Arbitration Lost */
;;;847            default:                                               /* Unknow status */
;;;848                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L14.18|
000012  6802              LDR      r2,[r0,#0]            ;822
000014  0712              LSLS     r2,r2,#28             ;822
000016  d5fc              BPL      |L14.18|
000018  68c2              LDR      r2,[r0,#0xc]          ;824
00001a  2a08              CMP      r2,#8                 ;824
00001c  d00b              BEQ      |L14.54|
00001e  2a40              CMP      r2,#0x40              ;824
000020  d00c              BEQ      |L14.60|
000022  2a48              CMP      r2,#0x48              ;824
000024  d00c              BEQ      |L14.64|
000026  2a58              CMP      r2,#0x58              ;824
000028  d00d              BEQ      |L14.70|
00002a  6802              LDR      r2,[r0,#0]
00002c  43b2              BICS     r2,r2,r6
00002e  3218              ADDS     r2,r2,#0x18
000030  6002              STR      r2,[r0,#0]
;;;849                u8Ctrl = I2C_CTL_SI;                         /* Clear SI and send STOP */
000032  2208              MOVS     r2,#8
;;;850                u8Err = 1;
;;;851                break;
000034  e005              B        |L14.66|
                  |L14.54|
000036  004a              LSLS     r2,r1,#1              ;827
000038  1c52              ADDS     r2,r2,#1              ;827
00003a  6082              STR      r2,[r0,#8]            ;827
                  |L14.60|
00003c  2208              MOVS     r2,#8                 ;832
00003e  e006              B        |L14.78|
                  |L14.64|
000040  2218              MOVS     r2,#0x18              ;836
                  |L14.66|
000042  2301              MOVS     r3,#1                 ;837
000044  e003              B        |L14.78|
                  |L14.70|
000046  6882              LDR      r2,[r0,#8]            ;841
000048  b2d4              UXTB     r4,r2                 ;841
00004a  2218              MOVS     r2,#0x18              ;842
00004c  2500              MOVS     r5,#0                 ;843
                  |L14.78|
;;;852            }
;;;853    
;;;854            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
00004e  6807              LDR      r7,[r0,#0]
000050  43b7              BICS     r7,r7,r6
000052  4317              ORRS     r7,r7,r2
000054  6007              STR      r7,[r0,#0]
000056  2d00              CMP      r5,#0                 ;820
000058  d002              BEQ      |L14.96|
00005a  2b00              CMP      r3,#0                 ;820
00005c  d0d9              BEQ      |L14.18|
00005e  e001              B        |L14.100|
                  |L14.96|
;;;855        }
;;;856    
;;;857        if (u8Err)
000060  2b00              CMP      r3,#0
000062  d000              BEQ      |L14.102|
                  |L14.100|
;;;858            u8rData = 0;                                                 /* If occurs error, return 0 */
000064  2400              MOVS     r4,#0
                  |L14.102|
;;;859    
;;;860        return u8rData;                                                  /* Return read data */
000066  4620              MOV      r0,r4
;;;861    }
000068  bdf0              POP      {r4-r7,pc}
;;;862    
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;952      */
;;;953    uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;954    {
;;;955        uint8_t u8Xfering = 1, u8Err = 0, u8rData = 0, u8Ctrl = 0;
000002  2601              MOVS     r6,#1
000004  2400              MOVS     r4,#0
;;;956    
;;;957        I2C_START(i2c);                                                /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  4625              MOV      r5,r4                 ;955
00000a  4622              MOV      r2,r4                 ;955
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;958    
;;;959        while (u8Xfering && (u8Err == 0))
;;;960        {
;;;961            I2C_WAIT_READY(i2c);
;;;962    
;;;963            switch (I2C_GET_STATUS(i2c))
;;;964            {
;;;965            case 0x08:
;;;966                I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L15.20|
000014  6801              LDR      r1,[r0,#0]            ;961
000016  0709              LSLS     r1,r1,#28             ;961
000018  d5fc              BPL      |L15.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;963
00001c  074b              LSLS     r3,r1,#29             ;963
00001e  0f5b              LSRS     r3,r3,#29             ;963
000020  d126              BNE      |L15.112|
000022  10c9              ASRS     r1,r1,#3              ;963
000024  000b              MOVS     r3,r1                 ;963
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c23              DCB      0x0c,0x23
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c2313          DCB      0x0f,0x0c,0x23,0x13
000034  0c231523          DCB      0x0c,0x23,0x15,0x23
000038  6087              STR      r7,[r0,#8]
;;;967                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;968                break;
00003a  e009              B        |L15.80|
;;;969    
;;;970            case 0x18:                                             /* Slave Address ACK */
;;;971                I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;972                break;
000040  e00c              B        |L15.92|
;;;973    
;;;974            case 0x20:                                             /* Slave Address NACK */
;;;975            case 0x30:                                             /* Master transmit data NACK */
;;;976                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L15.68|
;;;977                u8Err = 1;
000044  2401              MOVS     r4,#1
000046  e009              B        |L15.92|
;;;978                break;
;;;979    
;;;980            case 0x28:
;;;981                u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;982                break;
00004a  e007              B        |L15.92|
;;;983    
;;;984            case 0x10:
;;;985                I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  6081              STR      r1,[r0,#8]
                  |L15.80|
000050  2208              MOVS     r2,#8                 ;967
000052  e003              B        |L15.92|
;;;986                u8Ctrl = I2C_CTL_SI;                               /* Clear SI */
;;;987                break;
;;;988    
;;;989            case 0x40:                                             /* Slave Address ACK */
;;;990                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;991                break;
;;;992    
;;;993            case 0x48:                                             /* Slave Address NACK */
;;;994                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;995                u8Err = 1;
;;;996                break;
;;;997    
;;;998            case 0x58:
;;;999                u8rData = (uint8_t) I2C_GET_DATA(i2c);               /* Receive Data */
000054  6881              LDR      r1,[r0,#8]
;;;1000               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000056  2218              MOVS     r2,#0x18
000058  b2cd              UXTB     r5,r1                 ;999
;;;1001               u8Xfering = 0;
00005a  2600              MOVS     r6,#0
                  |L15.92|
;;;1002               break;
;;;1003   
;;;1004           case 0x38:                                             /* Arbitration Lost */
;;;1005           default:                                               /* Unknow status */
;;;1006               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1007               u8Ctrl = I2C_CTL_SI;                         /* Clear SI and send STOP */
;;;1008               u8Err = 1;
;;;1009               break;
;;;1010           }
;;;1011   
;;;1012           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
00005c  6801              LDR      r1,[r0,#0]
00005e  233c              MOVS     r3,#0x3c
000060  4399              BICS     r1,r1,r3
000062  4311              ORRS     r1,r1,r2
000064  6001              STR      r1,[r0,#0]
000066  2e00              CMP      r6,#0                 ;959
000068  d009              BEQ      |L15.126|
00006a  2c00              CMP      r4,#0                 ;959
00006c  d0d2              BEQ      |L15.20|
00006e  e008              B        |L15.130|
                  |L15.112|
000070  6801              LDR      r1,[r0,#0]            ;1006
000072  223c              MOVS     r2,#0x3c              ;1006
000074  4391              BICS     r1,r1,r2              ;1006
000076  3118              ADDS     r1,r1,#0x18           ;1006
000078  6001              STR      r1,[r0,#0]            ;1006
00007a  2208              MOVS     r2,#8                 ;1007
00007c  e7e2              B        |L15.68|
                  |L15.126|
;;;1013       }
;;;1014   
;;;1015       if (u8Err)
00007e  2c00              CMP      r4,#0
000080  d000              BEQ      |L15.132|
                  |L15.130|
;;;1016           u8rData = 0;                                                 /* If occurs error, return 0 */
000082  2500              MOVS     r5,#0
                  |L15.132|
;;;1017   
;;;1018       return u8rData;                                                  /* Return read data */
000084  4628              MOV      r0,r5
;;;1019   }
000086  bdfe              POP      {r1-r7,pc}
;;;1020   
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1124     */
;;;1125   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1126   {
;;;1127       uint8_t u8Xfering = 1, u8Err = 0, u8rData = 0, u8Addr = 1, u8Ctrl = 0;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1126
000006  2400              MOVS     r4,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1128   
;;;1129       I2C_START(i2c);                                                         /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  4625              MOV      r5,r4                 ;1127
000010  4622              MOV      r2,r4                 ;1127
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1130   
;;;1131       while (u8Xfering && (u8Err == 0))
;;;1132       {
;;;1133           I2C_WAIT_READY(i2c);
;;;1134   
;;;1135           switch (I2C_GET_STATUS(i2c))
;;;1136           {
;;;1137           case 0x08:
;;;1138               I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L16.26|
00001a  6801              LDR      r1,[r0,#0]            ;1133
00001c  0709              LSLS     r1,r1,#28             ;1133
00001e  d5fc              BPL      |L16.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1135
000022  074b              LSLS     r3,r1,#29             ;1135
000024  0f5b              LSRS     r3,r3,#29             ;1135
000026  d130              BNE      |L16.138|
000028  10c9              ASRS     r1,r1,#3              ;1135
00002a  000b              MOVS     r3,r1                 ;1135
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c2d0719          DCB      0x0c,0x2d,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  2d1b0d2d          DCB      0x2d,0x1b,0x0d,0x2d
00003c  1d2d              DCB      0x1d,0x2d
00003e  6087              STR      r7,[r0,#8]
;;;1139               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1140               break;
000040  e011              B        |L16.102|
;;;1141   
;;;1142           case 0x18:                                                      /* Slave Address ACK */
;;;1143               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1144               break;
000048  e014              B        |L16.116|
;;;1145   
;;;1146           case 0x20:                                                      /* Slave Address NACK */
;;;1147           case 0x30:                                                      /* Master transmit data NACK */
;;;1148               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L16.76|
;;;1149               u8Err = 1;
00004c  2401              MOVS     r4,#1
00004e  e011              B        |L16.116|
;;;1150               break;
;;;1151   
;;;1152           case 0x28:
;;;1153               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L16.94|
;;;1154               {
;;;1155                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1156                   u8Addr = 0;
00005a  2600              MOVS     r6,#0
00005c  e00a              B        |L16.116|
                  |L16.94|
;;;1157               }
;;;1158               else
;;;1159                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e008              B        |L16.116|
;;;1160   
;;;1161               break;
;;;1162   
;;;1163           case 0x10:
;;;1164               I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  6081              STR      r1,[r0,#8]
                  |L16.102|
000066  2208              MOVS     r2,#8                 ;1139
000068  e004              B        |L16.116|
;;;1165               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1166               break;
;;;1167   
;;;1168           case 0x40:                                                      /* Slave Address ACK */
;;;1169               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1170               break;
;;;1171   
;;;1172           case 0x48:                                                      /* Slave Address NACK */
;;;1173               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1174               u8Err = 1;
;;;1175               break;
;;;1176   
;;;1177           case 0x58:
;;;1178               u8rData = (unsigned char) I2C_GET_DATA(i2c);                  /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
;;;1179               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00006c  2218              MOVS     r2,#0x18
00006e  b2cd              UXTB     r5,r1                 ;1178
;;;1180               u8Xfering = 0;
000070  2100              MOVS     r1,#0
000072  9100              STR      r1,[sp,#0]
                  |L16.116|
;;;1181               break;
;;;1182   
;;;1183           case 0x38:                                                      /* Arbitration Lost */
;;;1184           default:                                                        /* Unknow status */
;;;1185               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1186               u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
;;;1187               u8Err = 1;
;;;1188               break;
;;;1189           }
;;;1190   
;;;1191           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000074  6801              LDR      r1,[r0,#0]
000076  233c              MOVS     r3,#0x3c
000078  4399              BICS     r1,r1,r3
00007a  4311              ORRS     r1,r1,r2
00007c  6001              STR      r1,[r0,#0]
00007e  9900              LDR      r1,[sp,#0]            ;1131
000080  2900              CMP      r1,#0                 ;1131
000082  d009              BEQ      |L16.152|
000084  2c00              CMP      r4,#0                 ;1131
000086  d0c8              BEQ      |L16.26|
000088  e008              B        |L16.156|
                  |L16.138|
00008a  6801              LDR      r1,[r0,#0]            ;1185
00008c  223c              MOVS     r2,#0x3c              ;1185
00008e  4391              BICS     r1,r1,r2              ;1185
000090  3118              ADDS     r1,r1,#0x18           ;1185
000092  6001              STR      r1,[r0,#0]            ;1185
000094  2208              MOVS     r2,#8                 ;1186
000096  e7d9              B        |L16.76|
                  |L16.152|
;;;1192       }
;;;1193   
;;;1194       if (u8Err)
000098  2c00              CMP      r4,#0
00009a  d000              BEQ      |L16.158|
                  |L16.156|
;;;1195           u8rData = 0;                                                          /* If occurs error, return 0 */
00009c  2500              MOVS     r5,#0
                  |L16.158|
;;;1196   
;;;1197       return u8rData;                                                           /* Return read data */
00009e  4628              MOV      r0,r5
;;;1198   }
0000a0  b004              ADD      sp,sp,#0x10
0000a2  bdf0              POP      {r4-r7,pc}
;;;1199   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;877      */
;;;878    uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t *pu8rData, uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;879    {
000002  468c              MOV      r12,r1
;;;880        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  2600              MOVS     r6,#0
;;;881        uint32_t u32rxLen = 0;
;;;882    
;;;883        I2C_START(i2c);                                                /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  469e              MOV      lr,r3                 ;879
00000c  4634              MOV      r4,r6                 ;881
00000e  2528              MOVS     r5,#0x28
000010  4329              ORRS     r1,r1,r5
000012  6001              STR      r1,[r0,#0]
;;;884    
;;;885        while (u8Xfering && (u8Err == 0))
;;;886        {
;;;887            I2C_WAIT_READY(i2c);
;;;888    
;;;889            switch (I2C_GET_STATUS(i2c))
;;;890            {
;;;891            case 0x08:
;;;892                I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
;;;893                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;894                break;
;;;895    
;;;896            case 0x40:                                             /* Slave Address ACK */
;;;897                u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;898                break;
;;;899    
;;;900            case 0x48:                                             /* Slave Address NACK */
;;;901                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;902                u8Err = 1;
;;;903                break;
;;;904    
;;;905            case 0x50:
;;;906                pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;907    
;;;908                if (u32rxLen < (u32rLen - 1))
;;;909                {
;;;910                    u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
;;;911                }
;;;912                else
;;;913                {
;;;914                    u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
;;;915                }
;;;916    
;;;917                break;
;;;918    
;;;919            case 0x58:
;;;920                pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;921                u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;922                u8Xfering = 0;
;;;923                break;
;;;924    
;;;925            case 0x38:                                                    /* Arbitration Lost */
;;;926            default:                                                      /* Unknow status */
;;;927                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000014  213c              MOVS     r1,#0x3c
                  |L17.22|
000016  6805              LDR      r5,[r0,#0]            ;887
000018  072d              LSLS     r5,r5,#28             ;887
00001a  d5fc              BPL      |L17.22|
00001c  68c5              LDR      r5,[r0,#0xc]          ;889
00001e  2d48              CMP      r5,#0x48              ;889
000020  d014              BEQ      |L17.76|
000022  dc04              BGT      |L17.46|
000024  2d08              CMP      r5,#8                 ;889
000026  d00c              BEQ      |L17.66|
000028  2d40              CMP      r5,#0x40              ;889
00002a  d104              BNE      |L17.54|
00002c  e018              B        |L17.96|
                  |L17.46|
00002e  2d50              CMP      r5,#0x50              ;889
000030  d00f              BEQ      |L17.82|
000032  2d58              CMP      r5,#0x58              ;889
000034  d018              BEQ      |L17.104|
                  |L17.54|
000036  6805              LDR      r5,[r0,#0]
000038  438d              BICS     r5,r5,r1
00003a  3518              ADDS     r5,r5,#0x18
00003c  6005              STR      r5,[r0,#0]
;;;928                u8Ctrl = I2C_CTL_SI;                                /* Clear SI and send STOP */
00003e  2508              MOVS     r5,#8
;;;929                u8Err = 1;
;;;930                break;
000040  e005              B        |L17.78|
                  |L17.66|
000042  4663              MOV      r3,r12                ;892
000044  005d              LSLS     r5,r3,#1              ;892
000046  1c6d              ADDS     r5,r5,#1              ;892
000048  6085              STR      r5,[r0,#8]            ;892
00004a  e00b              B        |L17.100|
                  |L17.76|
00004c  2518              MOVS     r5,#0x18              ;901
                  |L17.78|
00004e  2601              MOVS     r6,#1                 ;902
000050  e00f              B        |L17.114|
                  |L17.82|
000052  6885              LDR      r5,[r0,#8]            ;906
000054  5515              STRB     r5,[r2,r4]            ;906
000056  4673              MOV      r3,lr                 ;908
000058  1e5b              SUBS     r3,r3,#1              ;908
00005a  1c64              ADDS     r4,r4,#1              ;908
00005c  429c              CMP      r4,r3                 ;908
00005e  d201              BCS      |L17.100|
                  |L17.96|
000060  250c              MOVS     r5,#0xc               ;910
000062  e006              B        |L17.114|
                  |L17.100|
000064  2508              MOVS     r5,#8                 ;914
000066  e004              B        |L17.114|
                  |L17.104|
000068  6885              LDR      r5,[r0,#8]            ;920
00006a  5515              STRB     r5,[r2,r4]            ;920
00006c  2518              MOVS     r5,#0x18              ;921
00006e  2700              MOVS     r7,#0                 ;922
000070  1c64              ADDS     r4,r4,#1              ;922
                  |L17.114|
;;;931            }
;;;932    
;;;933            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                 /* Write controlbit to I2C_CTL register */
000072  6803              LDR      r3,[r0,#0]
000074  438b              BICS     r3,r3,r1
000076  431d              ORRS     r5,r5,r3
000078  6005              STR      r5,[r0,#0]
00007a  2f00              CMP      r7,#0                 ;885
00007c  d001              BEQ      |L17.130|
00007e  2e00              CMP      r6,#0                 ;885
000080  d0c9              BEQ      |L17.22|
                  |L17.130|
;;;934        }
;;;935    
;;;936        return u32rxLen;                                                      /* Return bytes length that have been received */
000082  4620              MOV      r0,r4
;;;937    }
000084  bdf0              POP      {r4-r7,pc}
;;;938    
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;1035     */
;;;1036   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *pu8rData, uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1037   {
;;;1038       uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000002  2601              MOVS     r6,#1
000004  2500              MOVS     r5,#0
;;;1039       uint32_t u32rxLen = 0;
;;;1040   
;;;1041       I2C_START(i2c);                                                /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  462a              MOV      r2,r5                 ;1038
00000a  462c              MOV      r4,r5                 ;1039
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;1042   
;;;1043       while (u8Xfering && (u8Err == 0))
;;;1044       {
;;;1045           I2C_WAIT_READY(i2c);
;;;1046   
;;;1047           switch (I2C_GET_STATUS(i2c))
;;;1048           {
;;;1049           case 0x08:
;;;1050               I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L18.20|
000014  6801              LDR      r1,[r0,#0]            ;1045
000016  0709              LSLS     r1,r1,#28             ;1045
000018  d5fc              BPL      |L18.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1047
00001c  074b              LSLS     r3,r1,#29             ;1047
00001e  0f5b              LSRS     r3,r3,#29             ;1047
000020  d135              BNE      |L18.142|
000022  10c9              ASRS     r1,r1,#3              ;1047
000024  000b              MOVS     r3,r1                 ;1047
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c32              DCB      0x0c,0x32
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c321c          DCB      0x0f,0x0c,0x32,0x1c
000034  0c142032          DCB      0x0c,0x14,0x20,0x32
000038  6087              STR      r7,[r0,#8]
;;;1051               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1052               break;
00003a  e014              B        |L18.102|
;;;1053   
;;;1054           case 0x18:                                             /* Slave Address ACK */
;;;1055               I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1056               break;
000040  e019              B        |L18.118|
;;;1057   
;;;1058           case 0x20:                                             /* Slave Address NACK */
;;;1059           case 0x30:                                             /* Master transmit data NACK */
;;;1060               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L18.68|
;;;1061               u8Err = 1;
000044  2501              MOVS     r5,#1
000046  e016              B        |L18.118|
;;;1062               break;
;;;1063   
;;;1064           case 0x28:
;;;1065               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1066               break;
00004a  e014              B        |L18.118|
;;;1067   
;;;1068           case 0x10:
;;;1069               I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  6081              STR      r1,[r0,#8]
;;;1070               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1071               break;
000050  e009              B        |L18.102|
;;;1072   
;;;1073           case 0x40:                                             /* Slave Address ACK */
;;;1074               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1075               break;
;;;1076   
;;;1077           case 0x48:                                             /* Slave Address NACK */
;;;1078               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1079               u8Err = 1;
;;;1080               break;
;;;1081   
;;;1082           case 0x50:
;;;1083               pu8rData[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000052  6881              LDR      r1,[r0,#8]
000054  9a03              LDR      r2,[sp,#0xc]
000056  5511              STRB     r1,[r2,r4]
;;;1084   
;;;1085               if (u32rxLen < (u32rLen - 1))
000058  9909              LDR      r1,[sp,#0x24]
00005a  1c64              ADDS     r4,r4,#1
00005c  1e49              SUBS     r1,r1,#1
00005e  428c              CMP      r4,r1
000060  d201              BCS      |L18.102|
;;;1086                   u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000062  220c              MOVS     r2,#0xc
000064  e007              B        |L18.118|
                  |L18.102|
;;;1087               else
;;;1088                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000066  2208              MOVS     r2,#8
000068  e005              B        |L18.118|
;;;1089   
;;;1090               break;
;;;1091   
;;;1092           case 0x58:
;;;1093               pu8rData[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
00006c  9a03              LDR      r2,[sp,#0xc]
;;;1094               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1095               u8Xfering = 0;
00006e  2600              MOVS     r6,#0
000070  5511              STRB     r1,[r2,r4]            ;1093
000072  2218              MOVS     r2,#0x18              ;1094
000074  1c64              ADDS     r4,r4,#1
                  |L18.118|
;;;1096               break;
;;;1097   
;;;1098           case 0x38:                                             /* Arbitration Lost */
;;;1099           default:                                               /* Unknow status */
;;;1100               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1101               u8Ctrl = I2C_CTL_SI;                         /* Clear SI and send STOP */
;;;1102               u8Err = 1;
;;;1103               break;
;;;1104           }
;;;1105   
;;;1106           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000076  6801              LDR      r1,[r0,#0]
000078  233c              MOVS     r3,#0x3c
00007a  4399              BICS     r1,r1,r3
00007c  4311              ORRS     r1,r1,r2
00007e  6001              STR      r1,[r0,#0]
000080  2e00              CMP      r6,#0                 ;1043
000082  d001              BEQ      |L18.136|
000084  2d00              CMP      r5,#0                 ;1043
000086  d0c5              BEQ      |L18.20|
                  |L18.136|
;;;1107       }
;;;1108   
;;;1109       return u32rxLen;                                               /* Return bytes length that have been received */
000088  4620              MOV      r0,r4
;;;1110   }
00008a  b004              ADD      sp,sp,#0x10
00008c  bdf0              POP      {r4-r7,pc}
                  |L18.142|
00008e  6801              LDR      r1,[r0,#0]            ;1100
000090  223c              MOVS     r2,#0x3c              ;1100
000092  4391              BICS     r1,r1,r2              ;1100
000094  3118              ADDS     r1,r1,#0x18           ;1100
000096  6001              STR      r1,[r0,#0]            ;1100
000098  2208              MOVS     r2,#8                 ;1101
00009a  e7d3              B        |L18.68|
;;;1111   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1214     */
;;;1215   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *pu8rData, uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1216   {
;;;1217       uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1216
000006  2500              MOVS     r5,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1218       uint32_t u32rxLen = 0;
;;;1219   
;;;1220       I2C_START(i2c);                                                         /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  462a              MOV      r2,r5                 ;1217
000010  462c              MOV      r4,r5                 ;1218
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1221   
;;;1222       while (u8Xfering && (u8Err == 0))
;;;1223       {
;;;1224           I2C_WAIT_READY(i2c);
;;;1225   
;;;1226           switch (I2C_GET_STATUS(i2c))
;;;1227           {
;;;1228           case 0x08:
;;;1229               I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L19.26|
00001a  6801              LDR      r1,[r0,#0]            ;1224
00001c  0709              LSLS     r1,r1,#28             ;1224
00001e  d5fc              BPL      |L19.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1226
000022  074b              LSLS     r3,r1,#29             ;1226
000024  0f5b              LSRS     r3,r3,#29             ;1226
000026  d13f              BNE      |L19.168|
000028  10c9              ASRS     r1,r1,#3              ;1226
00002a  000b              MOVS     r3,r1                 ;1226
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c3c0719          DCB      0x0c,0x3c,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  3c240d1c          DCB      0x3c,0x24,0x0d,0x1c
00003c  283c              DCB      0x28,0x3c
00003e  6087              STR      r7,[r0,#8]
;;;1230               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1231               break;
000040  e01c              B        |L19.124|
;;;1232   
;;;1233           case 0x18:                                                      /* Slave Address ACK */
;;;1234               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1235               break;
000048  e021              B        |L19.142|
;;;1236   
;;;1237           case 0x20:                                                      /* Slave Address NACK */
;;;1238           case 0x30:                                                      /* Master transmit data NACK */
;;;1239               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L19.76|
;;;1240               u8Err = 1;
00004c  2501              MOVS     r5,#1
00004e  e01e              B        |L19.142|
;;;1241               break;
;;;1242   
;;;1243           case 0x28:
;;;1244               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L19.94|
;;;1245               {
;;;1246                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1247                   u8Addr = 0;
00005a  2600              MOVS     r6,#0
00005c  e017              B        |L19.142|
                  |L19.94|
;;;1248               }
;;;1249               else
;;;1250                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e015              B        |L19.142|
;;;1251   
;;;1252               break;
;;;1253   
;;;1254           case 0x10:
;;;1255               I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  6081              STR      r1,[r0,#8]
;;;1256               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1257               break;
000066  e009              B        |L19.124|
;;;1258   
;;;1259           case 0x40:                                                      /* Slave Address ACK */
;;;1260               u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1261               break;
;;;1262   
;;;1263           case 0x48:                                                      /* Slave Address NACK */
;;;1264               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1265               u8Err = 1;
;;;1266               break;
;;;1267   
;;;1268           case 0x50:
;;;1269               pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000068  6881              LDR      r1,[r0,#8]
00006a  9a04              LDR      r2,[sp,#0x10]
00006c  5511              STRB     r1,[r2,r4]
;;;1270   
;;;1271               if (u32rxLen < (u32rLen - 1))
00006e  990a              LDR      r1,[sp,#0x28]
000070  1c64              ADDS     r4,r4,#1
000072  1e49              SUBS     r1,r1,#1
000074  428c              CMP      r4,r1
000076  d201              BCS      |L19.124|
;;;1272                   u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
000078  220c              MOVS     r2,#0xc
00007a  e008              B        |L19.142|
                  |L19.124|
;;;1273               else
;;;1274                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
00007c  2208              MOVS     r2,#8
00007e  e006              B        |L19.142|
;;;1275   
;;;1276               break;
;;;1277   
;;;1278           case 0x58:
;;;1279               pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000080  6881              LDR      r1,[r0,#8]
000082  9a04              LDR      r2,[sp,#0x10]
000084  5511              STRB     r1,[r2,r4]
;;;1280               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1281               u8Xfering = 0;
000086  2100              MOVS     r1,#0
000088  2218              MOVS     r2,#0x18              ;1280
00008a  1c64              ADDS     r4,r4,#1
00008c  9100              STR      r1,[sp,#0]
                  |L19.142|
;;;1282               break;
;;;1283   
;;;1284           case 0x38:                                                      /* Arbitration Lost */
;;;1285           default:                                                        /* Unknow status */
;;;1286               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1287               u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
;;;1288               u8Err = 1;
;;;1289               break;
;;;1290           }
;;;1291   
;;;1292           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
00008e  6801              LDR      r1,[r0,#0]
000090  233c              MOVS     r3,#0x3c
000092  4399              BICS     r1,r1,r3
000094  4311              ORRS     r1,r1,r2
000096  6001              STR      r1,[r0,#0]
000098  9900              LDR      r1,[sp,#0]            ;1222
00009a  2900              CMP      r1,#0                 ;1222
00009c  d001              BEQ      |L19.162|
00009e  2d00              CMP      r5,#0                 ;1222
0000a0  d0bb              BEQ      |L19.26|
                  |L19.162|
;;;1293       }
;;;1294   
;;;1295       return u32rxLen;                                                        /* Return bytes length that have been received */
0000a2  4620              MOV      r0,r4
;;;1296   }
0000a4  b005              ADD      sp,sp,#0x14
0000a6  bdf0              POP      {r4-r7,pc}
                  |L19.168|
0000a8  6801              LDR      r1,[r0,#0]            ;1286
0000aa  223c              MOVS     r2,#0x3c              ;1286
0000ac  4391              BICS     r1,r1,r2              ;1286
0000ae  3118              ADDS     r1,r1,#0x18           ;1286
0000b0  6001              STR      r1,[r0,#0]            ;1286
0000b2  2208              MOVS     r2,#8                 ;1287
0000b4  e7ca              B        |L19.76|
;;;1297   
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;181     */
;;;182    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;183    {
000002  4604              MOV      r4,r0
;;;184        uint32_t u32Div;
;;;185    
;;;186        u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000004  4809              LDR      r0,|L20.44|
000006  220a              MOVS     r2,#0xa
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  0089              LSLS     r1,r1,#2
00000c  4605              MOV      r5,r0
00000e  4350              MULS     r0,r2,r0
000010  f7fffffe          BL       __aeabi_uidivmod
000014  210a              MOVS     r1,#0xa
000016  1d40              ADDS     r0,r0,#5
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  1e40              SUBS     r0,r0,#1
;;;187        i2c->CLKDIV = u32Div;
00001e  6120              STR      r0,[r4,#0x10]
;;;188    
;;;189        return (SystemCoreClock / ((u32Div + 1) << 2));
000020  0081              LSLS     r1,r0,#2
000022  4628              MOV      r0,r5
000024  1d09              ADDS     r1,r1,#4
000026  f7fffffe          BL       __aeabi_uidivmod
;;;190    }
00002a  bd70              POP      {r4-r6,pc}
;;;191    
                          ENDP

                  |L20.44|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;243     */
;;;244    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;245    {
;;;246        i2c->DAT = u8Data;
;;;247    }
000002  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;262     */
;;;263    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;264    {
;;;265        switch (u8SlaveNo)
;;;266        {
;;;267        case 1:
;;;268            i2c->ADDR1  = (u8SlaveAddr << 1) | u8GCMode;
000002  431a              ORRS     r2,r2,r3
000004  2901              CMP      r1,#1                 ;265
000006  d005              BEQ      |L22.20|
000008  2902              CMP      r1,#2                 ;265
00000a  d005              BEQ      |L22.24|
00000c  2903              CMP      r1,#3                 ;265
00000e  d005              BEQ      |L22.28|
;;;269            break;
;;;270    
;;;271        case 2:
;;;272            i2c->ADDR2  = (u8SlaveAddr << 1) | u8GCMode;
;;;273            break;
;;;274    
;;;275        case 3:
;;;276            i2c->ADDR3  = (u8SlaveAddr << 1) | u8GCMode;
;;;277            break;
;;;278    
;;;279        case 0:
;;;280        default:
;;;281            i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;282            break;
;;;283        }
;;;284    }
000012  4770              BX       lr
                  |L22.20|
000014  6182              STR      r2,[r0,#0x18]         ;268
000016  4770              BX       lr
                  |L22.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;272
00001a  4770              BX       lr
                  |L22.28|
00001c  6202              STR      r2,[r0,#0x20]         ;276
00001e  4770              BX       lr
;;;285    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;297     */
;;;298    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;299    {
;;;300        switch (u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L23.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L23.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L23.26|
;;;301        {
;;;302        case 1:
;;;303            i2c->ADDRMSK1  = u8SlaveAddrMask << 1;
;;;304            break;
;;;305    
;;;306        case 2:
;;;307            i2c->ADDRMSK2  = u8SlaveAddrMask << 1;
;;;308            break;
;;;309    
;;;310        case 3:
;;;311            i2c->ADDRMSK3  = u8SlaveAddrMask << 1;
;;;312            break;
;;;313    
;;;314        case 0:
;;;315        default:
;;;316            i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
00000e  6242              STR      r2,[r0,#0x24]
;;;317            break;
;;;318        }
;;;319    }
000010  4770              BX       lr
                  |L23.18|
000012  6282              STR      r2,[r0,#0x28]         ;303
000014  4770              BX       lr
                  |L23.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;307
000018  4770              BX       lr
                  |L23.26|
00001a  6302              STR      r2,[r0,#0x30]         ;311
00001c  4770              BX       lr
;;;320    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;106      */
;;;107    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;108    {
;;;109        uint32_t u32Reg = 0;
000002  2400              MOVS     r4,#0
;;;110    
;;;111        if (u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L24.12|
;;;112            u32Reg |= I2C_CTL_STA;
00000a  2420              MOVS     r4,#0x20
                  |L24.12|
;;;113    
;;;114        if (u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L24.20|
;;;115            u32Reg |= I2C_CTL_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L24.20|
;;;116    
;;;117        if (u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L24.28|
;;;118            u32Reg |= I2C_CTL_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L24.28|
;;;119    
;;;120        if (u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L24.36|
;;;121            u32Reg |= I2C_CTL_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L24.36|
;;;122    
;;;123        i2c->CTL = (i2c->CTL & ~0x3C) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;124    }
00002e  bd30              POP      {r4,r5,pc}
;;;125    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;402    
;;;403    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t u8Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;404    {
;;;405        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;406    
;;;407        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;405
00000a  2728              MOVS     r7,#0x28
00000c  433e              ORRS     r6,r6,r7
00000e  6006              STR      r6,[r0,#0]
;;;408    
;;;409        while (u8Xfering && (u8Err == 0))
;;;410        {
;;;411            I2C_WAIT_READY(i2c);
;;;412    
;;;413            switch (I2C_GET_STATUS(i2c))
;;;414            {
;;;415            case 0x08:
;;;416                I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;417                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;418                break;
;;;419    
;;;420            case 0x18:                                           /* Slave Address ACK */
;;;421                I2C_SET_DATA(i2c, u8Data);                         /* Write data to I2CDAT */
;;;422                break;
;;;423    
;;;424            case 0x20:                                           /* Slave Address NACK */
;;;425            case 0x30:                                           /* Master transmit data NACK */
;;;426                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;427                u8Err = 1;
;;;428                break;
;;;429    
;;;430            case 0x28:
;;;431                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;432                u8Xfering = 0;
;;;433                break;
;;;434    
;;;435            case 0x38:                                           /* Arbitration Lost */
;;;436            default:                                             /* Unknow status */
;;;437                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L25.18|
000012  6807              LDR      r7,[r0,#0]            ;411
000014  073f              LSLS     r7,r7,#28             ;411
000016  d5fc              BPL      |L25.18|
000018  68c7              LDR      r7,[r0,#0xc]          ;413
00001a  2f20              CMP      r7,#0x20              ;413
00001c  d015              BEQ      |L25.74|
00001e  dc04              BGT      |L25.42|
000020  2f08              CMP      r7,#8                 ;413
000022  d00c              BEQ      |L25.62|
000024  2f18              CMP      r7,#0x18              ;413
000026  d104              BNE      |L25.50|
000028  e00d              B        |L25.70|
                  |L25.42|
00002a  2f28              CMP      r7,#0x28              ;413
00002c  d010              BEQ      |L25.80|
00002e  2f30              CMP      r7,#0x30              ;413
000030  d00b              BEQ      |L25.74|
                  |L25.50|
000032  6803              LDR      r3,[r0,#0]
000034  43b3              BICS     r3,r3,r6
000036  3318              ADDS     r3,r3,#0x18
000038  6003              STR      r3,[r0,#0]
;;;438                u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
00003a  2308              MOVS     r3,#8
;;;439                u8Err = 1;
;;;440                break;
00003c  e006              B        |L25.76|
                  |L25.62|
00003e  004b              LSLS     r3,r1,#1              ;416
000040  6083              STR      r3,[r0,#8]            ;416
000042  2308              MOVS     r3,#8                 ;417
000044  e006              B        |L25.84|
                  |L25.70|
000046  6082              STR      r2,[r0,#8]            ;421
000048  e004              B        |L25.84|
                  |L25.74|
00004a  2318              MOVS     r3,#0x18              ;426
                  |L25.76|
00004c  2401              MOVS     r4,#1                 ;427
00004e  e001              B        |L25.84|
                  |L25.80|
000050  2318              MOVS     r3,#0x18              ;431
000052  2500              MOVS     r5,#0                 ;432
                  |L25.84|
;;;441            }
;;;442    
;;;443            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000054  6807              LDR      r7,[r0,#0]
000056  43b7              BICS     r7,r7,r6
000058  431f              ORRS     r7,r7,r3
00005a  6007              STR      r7,[r0,#0]
00005c  2d00              CMP      r5,#0                 ;409
00005e  d001              BEQ      |L25.100|
000060  2c00              CMP      r4,#0                 ;409
000062  d0d6              BEQ      |L25.18|
                  |L25.100|
000064  4620              MOV      r0,r4                 ;409
;;;444        }
;;;445    
;;;446        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000066  4328              ORRS     r0,r0,r5
;;;447    }
000068  bdf0              POP      {r4-r7,pc}
;;;448    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;527    
;;;528    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t u8Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;529    {
000002  469e              MOV      lr,r3
;;;530        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2601              MOVS     r6,#1
000006  4613              MOV      r3,r2                 ;529
000008  2500              MOVS     r5,#0
;;;531        uint32_t u32txLen = 0;
;;;532    
;;;533        I2C_START(i2c);                                              /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;529
00000e  462c              MOV      r4,r5                 ;530
000010  462f              MOV      r7,r5                 ;531
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;534    
;;;535        while (u8Xfering && (u8Err == 0))
;;;536        {
;;;537            I2C_WAIT_READY(i2c);
;;;538    
;;;539            switch (I2C_GET_STATUS(i2c))
;;;540            {
;;;541            case 0x08:
;;;542                I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Send Slave address with write bit */
;;;543                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;544                break;
;;;545    
;;;546            case 0x18:                                           /* Slave Address ACK */
;;;547                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;548                break;
;;;549    
;;;550            case 0x20:                                           /* Slave Address NACK */
;;;551            case 0x30:                                           /* Master transmit data NACK */
;;;552                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;553                u8Err = 1;
;;;554                break;
;;;555    
;;;556            case 0x28:
;;;557                if (u32txLen < 1)
;;;558                {
;;;559                    I2C_SET_DATA(i2c, u8Data);
;;;560                    u32txLen++;
;;;561                }
;;;562                else
;;;563                {
;;;564                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;565                    u8Xfering = 0;
;;;566                }
;;;567    
;;;568                break;
;;;569    
;;;570            case 0x38:                                           /* Arbitration Lost */
;;;571            default:                                             /* Unknow status */
;;;572                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L26.26|
00001a  6801              LDR      r1,[r0,#0]            ;537
00001c  0709              LSLS     r1,r1,#28             ;537
00001e  d5fc              BPL      |L26.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;539
000022  2920              CMP      r1,#0x20              ;539
000024  d016              BEQ      |L26.84|
000026  dc04              BGT      |L26.50|
000028  2908              CMP      r1,#8                 ;539
00002a  d00c              BEQ      |L26.70|
00002c  2918              CMP      r1,#0x18              ;539
00002e  d104              BNE      |L26.58|
000030  e00e              B        |L26.80|
                  |L26.50|
000032  2928              CMP      r1,#0x28              ;539
000034  d011              BEQ      |L26.90|
000036  2930              CMP      r1,#0x30              ;539
000038  d00c              BEQ      |L26.84|
                  |L26.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;573                u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
000042  2408              MOVS     r4,#8
;;;574                u8Err = 1;
;;;575                break;
000044  e007              B        |L26.86|
                  |L26.70|
000046  4661              MOV      r1,r12                ;542
000048  004c              LSLS     r4,r1,#1              ;542
00004a  6084              STR      r4,[r0,#8]            ;542
00004c  2408              MOVS     r4,#8                 ;543
00004e  e00c              B        |L26.106|
                  |L26.80|
000050  6083              STR      r3,[r0,#8]            ;547
000052  e00a              B        |L26.106|
                  |L26.84|
000054  2418              MOVS     r4,#0x18              ;552
                  |L26.86|
000056  2501              MOVS     r5,#1                 ;553
000058  e007              B        |L26.106|
                  |L26.90|
00005a  2f00              CMP      r7,#0                 ;557
00005c  d002              BEQ      |L26.100|
00005e  2418              MOVS     r4,#0x18              ;564
000060  2600              MOVS     r6,#0                 ;565
000062  e002              B        |L26.106|
                  |L26.100|
000064  4671              MOV      r1,lr                 ;559
000066  6081              STR      r1,[r0,#8]            ;559
000068  2701              MOVS     r7,#1                 ;560
                  |L26.106|
;;;576            }
;;;577    
;;;578            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00006a  6801              LDR      r1,[r0,#0]
00006c  4391              BICS     r1,r1,r2
00006e  4321              ORRS     r1,r1,r4
000070  6001              STR      r1,[r0,#0]
000072  2e00              CMP      r6,#0                 ;535
000074  d001              BEQ      |L26.122|
000076  2d00              CMP      r5,#0                 ;535
000078  d0cf              BEQ      |L26.26|
                  |L26.122|
00007a  4628              MOV      r0,r5                 ;535
;;;579        }
;;;580    
;;;581        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
00007c  4330              ORRS     r0,r0,r6
;;;582    }
00007e  bdf0              POP      {r4-r7,pc}
;;;583    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;667    
;;;668    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t u8Data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;669    {
;;;670        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  468e              MOV      lr,r1                 ;669
000006  2400              MOVS     r4,#0
;;;671        uint32_t u32txLen = 0;
;;;672    
;;;673        I2C_START(i2c);                                                         /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;669
00000c  462f              MOV      r7,r5                 ;670
00000e  4623              MOV      r3,r4                 ;670
000010  4626              MOV      r6,r4                 ;671
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L27.24|
;;;674    
;;;675        while (u8Xfering && (u8Err == 0))
;;;676        {
;;;677            I2C_WAIT_READY(i2c);
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L27.24|
;;;678    
;;;679            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d019              BEQ      |L27.88|
000024  dc04              BGT      |L27.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L27.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L27.56|
00002e  e00f              B        |L27.80|
                  |L27.48|
000030  2a28              CMP      r2,#0x28
000032  d014              BEQ      |L27.94|
000034  2a30              CMP      r2,#0x30
000036  d00f              BEQ      |L27.88|
                  |L27.56|
;;;680            {
;;;681            case 0x08:
;;;682                I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
;;;683                u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;684                break;
;;;685    
;;;686            case 0x18:                                                      /* Slave Address ACK */
;;;687                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
;;;688                break;
;;;689    
;;;690            case 0x20:                                                      /* Slave Address NACK */
;;;691            case 0x30:                                                      /* Master transmit data NACK */
;;;692                u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;693                u8Err = 1;
;;;694                break;
;;;695    
;;;696            case 0x28:
;;;697                if (u8Addr)
;;;698                {
;;;699                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
;;;700                    u8Addr = 0;
;;;701                }
;;;702                else if ((u32txLen < 1) && (u8Addr == 0))
;;;703                {
;;;704                    I2C_SET_DATA(i2c, u8Data);
;;;705                    u32txLen++;
;;;706                }
;;;707                else
;;;708                {
;;;709                    u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;710                    u8Xfering = 0;
;;;711                }
;;;712    
;;;713                break;
;;;714    
;;;715            case 0x38:                                                      /* Arbitration Lost */
;;;716            default:                                                        /* Unknow status */
;;;717                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;718                u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
000042  2308              MOVS     r3,#8
;;;719                u8Err = 1;
;;;720                break;
000044  e009              B        |L27.90|
                  |L27.70|
000046  4671              MOV      r1,lr                 ;682
000048  0049              LSLS     r1,r1,#1              ;682
00004a  6081              STR      r1,[r0,#8]            ;682
00004c  2308              MOVS     r3,#8                 ;683
00004e  e015              B        |L27.124|
                  |L27.80|
000050  4661              MOV      r1,r12                ;687
000052  0a0a              LSRS     r2,r1,#8              ;687
000054  6082              STR      r2,[r0,#8]            ;687
000056  e011              B        |L27.124|
                  |L27.88|
000058  2318              MOVS     r3,#0x18              ;692
                  |L27.90|
00005a  2401              MOVS     r4,#1                 ;693
00005c  e00e              B        |L27.124|
                  |L27.94|
00005e  2f00              CMP      r7,#0                 ;697
000060  d004              BEQ      |L27.108|
000062  4661              MOV      r1,r12                ;699
000064  b2c9              UXTB     r1,r1                 ;699
000066  6081              STR      r1,[r0,#8]            ;699
000068  2700              MOVS     r7,#0                 ;700
00006a  e007              B        |L27.124|
                  |L27.108|
00006c  2e00              CMP      r6,#0                 ;702
00006e  d002              BEQ      |L27.118|
000070  2318              MOVS     r3,#0x18              ;709
000072  2500              MOVS     r5,#0                 ;710
000074  e002              B        |L27.124|
                  |L27.118|
000076  9903              LDR      r1,[sp,#0xc]          ;704
000078  6081              STR      r1,[r0,#8]            ;704
00007a  2601              MOVS     r6,#1                 ;705
                  |L27.124|
;;;721            }
;;;722    
;;;723            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
00007c  6801              LDR      r1,[r0,#0]
00007e  223c              MOVS     r2,#0x3c
000080  4391              BICS     r1,r1,r2
000082  460a              MOV      r2,r1
000084  431a              ORRS     r2,r2,r3
000086  6002              STR      r2,[r0,#0]
000088  2d00              CMP      r5,#0                 ;675
00008a  d001              BEQ      |L27.144|
00008c  2c00              CMP      r4,#0                 ;675
00008e  d0c3              BEQ      |L27.24|
                  |L27.144|
000090  4620              MOV      r0,r4                 ;675
;;;724        }
;;;725    
;;;726        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
000092  4328              ORRS     r0,r0,r5
;;;727    }
000094  b004              ADD      sp,sp,#0x10
000096  bdf0              POP      {r4-r7,pc}
;;;728    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;462    
;;;463    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t *pu8Data, uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;464    {
000002  469e              MOV      lr,r3
;;;465        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  4613              MOV      r3,r2                 ;464
000008  2600              MOVS     r6,#0
;;;466        uint32_t u32txLen = 0;
;;;467    
;;;468        I2C_START(i2c);                                              /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;464
00000e  4634              MOV      r4,r6                 ;465
000010  4635              MOV      r5,r6                 ;466
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;469    
;;;470        while (u8Xfering && (u8Err == 0))
;;;471        {
;;;472            I2C_WAIT_READY(i2c);
;;;473    
;;;474            switch (I2C_GET_STATUS(i2c))
;;;475            {
;;;476            case 0x08:
;;;477                I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;478                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;479                break;
;;;480    
;;;481            case 0x18:                                           /* Slave Address ACK */
;;;482            case 0x28:
;;;483                if (u32txLen < u32wLen)
;;;484                    I2C_SET_DATA(i2c, pu8Data[u32txLen++]);                /* Write Data to I2CDAT */
;;;485                else
;;;486                {
;;;487                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;488                    u8Xfering = 0;
;;;489                }
;;;490    
;;;491                break;
;;;492    
;;;493            case 0x20:                                           /* Slave Address NACK */
;;;494            case 0x30:                                           /* Master transmit data NACK */
;;;495                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;496                u8Err = 1;
;;;497                break;
;;;498    
;;;499            case 0x38:                                           /* Arbitration Lost */
;;;500            default:                                             /* Unknow status */
;;;501                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L28.26|
00001a  6801              LDR      r1,[r0,#0]            ;472
00001c  0709              LSLS     r1,r1,#28             ;472
00001e  d5fc              BPL      |L28.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;474
000022  2920              CMP      r1,#0x20              ;474
000024  d01d              BEQ      |L28.98|
000026  dc04              BGT      |L28.50|
000028  2908              CMP      r1,#8                 ;474
00002a  d00c              BEQ      |L28.70|
00002c  2918              CMP      r1,#0x18              ;474
00002e  d104              BNE      |L28.58|
000030  e00e              B        |L28.80|
                  |L28.50|
000032  2928              CMP      r1,#0x28              ;474
000034  d00c              BEQ      |L28.80|
000036  2930              CMP      r1,#0x30              ;474
000038  d013              BEQ      |L28.98|
                  |L28.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;502                u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
000042  2408              MOVS     r4,#8
;;;503                u8Err = 1;
;;;504                break;
000044  e00e              B        |L28.100|
                  |L28.70|
000046  4661              MOV      r1,r12                ;477
000048  004c              LSLS     r4,r1,#1              ;477
00004a  6084              STR      r4,[r0,#8]            ;477
00004c  2408              MOVS     r4,#8                 ;478
00004e  e00a              B        |L28.102|
                  |L28.80|
000050  4575              CMP      r5,lr                 ;483
000052  d203              BCS      |L28.92|
000054  5d59              LDRB     r1,[r3,r5]            ;484
000056  6081              STR      r1,[r0,#8]            ;484
000058  1c6d              ADDS     r5,r5,#1              ;484
00005a  e004              B        |L28.102|
                  |L28.92|
00005c  2418              MOVS     r4,#0x18              ;487
00005e  2700              MOVS     r7,#0                 ;488
000060  e001              B        |L28.102|
                  |L28.98|
000062  2418              MOVS     r4,#0x18              ;495
                  |L28.100|
000064  2601              MOVS     r6,#1                 ;496
                  |L28.102|
;;;505            }
;;;506    
;;;507            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000066  6801              LDR      r1,[r0,#0]
000068  4391              BICS     r1,r1,r2
00006a  4321              ORRS     r1,r1,r4
00006c  6001              STR      r1,[r0,#0]
00006e  2f00              CMP      r7,#0                 ;470
000070  d001              BEQ      |L28.118|
000072  2e00              CMP      r6,#0                 ;470
000074  d0d1              BEQ      |L28.26|
                  |L28.118|
;;;508        }
;;;509    
;;;510        return u32txLen;                                             /* Return bytes length that have been transmitted */
000076  4628              MOV      r0,r5
;;;511    }
000078  bdf0              POP      {r4-r7,pc}
;;;512    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;599    
;;;600    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t *pu8Data, uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;601    {
000002  469e              MOV      lr,r3
;;;602        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  460b              MOV      r3,r1                 ;601
000008  2600              MOVS     r6,#0
;;;603        uint32_t u32txLen = 0;
;;;604    
;;;605        I2C_START(i2c);                                              /* Send START */
00000a  6801              LDR      r1,[r0,#0]
00000c  4694              MOV      r12,r2                ;601
00000e  4634              MOV      r4,r6                 ;602
000010  4635              MOV      r5,r6                 ;603
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;606    
;;;607        while (u8Xfering && (u8Err == 0))
;;;608        {
;;;609            I2C_WAIT_READY(i2c);
;;;610    
;;;611            switch (I2C_GET_STATUS(i2c))
;;;612            {
;;;613            case 0x08:
;;;614                I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;615                u8Ctrl = I2C_CTL_SI;
;;;616                break;
;;;617    
;;;618            case 0x18:                                           /* Slave Address ACK */
;;;619                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;620                break;
;;;621    
;;;622            case 0x20:                                           /* Slave Address NACK */
;;;623            case 0x30:                                           /* Master transmit data NACK */
;;;624                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;625                u8Err = 1;
;;;626                break;
;;;627    
;;;628            case 0x28:
;;;629                if (u32txLen < u32wLen)
;;;630                    I2C_SET_DATA(i2c, pu8Data[u32txLen++]);
;;;631                else
;;;632                {
;;;633                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;634                    u8Xfering = 0;
;;;635                }
;;;636    
;;;637                break;
;;;638    
;;;639            case 0x38:                                           /* Arbitration Lost */
;;;640            default:                                             /* Unknow status */
;;;641                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L29.26|
00001a  6801              LDR      r1,[r0,#0]            ;609
00001c  0709              LSLS     r1,r1,#28             ;609
00001e  d5fc              BPL      |L29.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;611
000022  2920              CMP      r1,#0x20              ;611
000024  d016              BEQ      |L29.84|
000026  dc04              BGT      |L29.50|
000028  2908              CMP      r1,#8                 ;611
00002a  d00c              BEQ      |L29.70|
00002c  2918              CMP      r1,#0x18              ;611
00002e  d104              BNE      |L29.58|
000030  e00d              B        |L29.78|
                  |L29.50|
000032  2928              CMP      r1,#0x28              ;611
000034  d011              BEQ      |L29.90|
000036  2930              CMP      r1,#0x30              ;611
000038  d00c              BEQ      |L29.84|
                  |L29.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;642                u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
000042  2408              MOVS     r4,#8
;;;643                u8Err = 1;
;;;644                break;
000044  e007              B        |L29.86|
                  |L29.70|
000046  005c              LSLS     r4,r3,#1              ;614
000048  6084              STR      r4,[r0,#8]            ;614
00004a  2408              MOVS     r4,#8                 ;615
00004c  e00f              B        |L29.110|
                  |L29.78|
00004e  4661              MOV      r1,r12                ;619
000050  6081              STR      r1,[r0,#8]            ;619
000052  e00c              B        |L29.110|
                  |L29.84|
000054  2418              MOVS     r4,#0x18              ;624
                  |L29.86|
000056  2601              MOVS     r6,#1                 ;625
000058  e009              B        |L29.110|
                  |L29.90|
00005a  9905              LDR      r1,[sp,#0x14]         ;629
00005c  428d              CMP      r5,r1                 ;629
00005e  d204              BCS      |L29.106|
000060  4671              MOV      r1,lr                 ;630
000062  5d49              LDRB     r1,[r1,r5]            ;630
000064  6081              STR      r1,[r0,#8]            ;630
000066  1c6d              ADDS     r5,r5,#1              ;630
000068  e001              B        |L29.110|
                  |L29.106|
00006a  2418              MOVS     r4,#0x18              ;633
00006c  2700              MOVS     r7,#0                 ;634
                  |L29.110|
;;;645            }
;;;646    
;;;647            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00006e  6801              LDR      r1,[r0,#0]
000070  4391              BICS     r1,r1,r2
000072  4321              ORRS     r1,r1,r4
000074  6001              STR      r1,[r0,#0]
000076  2f00              CMP      r7,#0                 ;607
000078  d001              BEQ      |L29.126|
00007a  2e00              CMP      r6,#0                 ;607
00007c  d0cd              BEQ      |L29.26|
                  |L29.126|
;;;648        }
;;;649    
;;;650        return u32txLen;                                             /* Return bytes length that have been transmitted */
00007e  4628              MOV      r0,r5
;;;651    }
000080  bdf0              POP      {r4-r7,pc}
;;;652    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;744    
;;;745    uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t *pu8Data, uint32_t u32wLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;746    {
;;;747        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2701              MOVS     r7,#1
000004  468e              MOV      lr,r1                 ;746
000006  2500              MOVS     r5,#0
;;;748        uint32_t u32txLen = 0;
;;;749    
;;;750        I2C_START(i2c);                                                         /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;746
00000c  463e              MOV      r6,r7                 ;747
00000e  462b              MOV      r3,r5                 ;747
000010  462c              MOV      r4,r5                 ;748
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L30.24|
;;;751    
;;;752        while (u8Xfering && (u8Err == 0))
;;;753        {
;;;754            I2C_WAIT_READY(i2c);
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L30.24|
;;;755    
;;;756            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d019              BEQ      |L30.88|
000024  dc04              BGT      |L30.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L30.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L30.56|
00002e  e00f              B        |L30.80|
                  |L30.48|
000030  2a28              CMP      r2,#0x28
000032  d014              BEQ      |L30.94|
000034  2a30              CMP      r2,#0x30
000036  d00f              BEQ      |L30.88|
                  |L30.56|
;;;757            {
;;;758            case 0x08:
;;;759                I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
;;;760                u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;761                break;
;;;762    
;;;763            case 0x18:                                                      /* Slave Address ACK */
;;;764                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
;;;765                break;
;;;766    
;;;767            case 0x20:                                                      /* Slave Address NACK */
;;;768            case 0x30:                                                      /* Master transmit data NACK */
;;;769                u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;770                u8Err = 1;
;;;771                break;
;;;772    
;;;773            case 0x28:
;;;774                if (u8Addr)
;;;775                {
;;;776                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
;;;777                    u8Addr = 0;
;;;778                }
;;;779                else if ((u32txLen < u32wLen) && (u8Addr == 0))
;;;780                    I2C_SET_DATA(i2c, pu8Data[u32txLen++]);                           /* Write data to Register I2CDAT*/
;;;781                else
;;;782                {
;;;783                    u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;784                    u8Xfering = 0;
;;;785                }
;;;786    
;;;787                break;
;;;788    
;;;789            case 0x38:                                                      /* Arbitration Lost */
;;;790            default:                                                        /* Unknow status */
;;;791                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;792                u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
000042  2308              MOVS     r3,#8
;;;793                u8Err = 1;
;;;794                break;
000044  e009              B        |L30.90|
                  |L30.70|
000046  4671              MOV      r1,lr                 ;759
000048  0049              LSLS     r1,r1,#1              ;759
00004a  6081              STR      r1,[r0,#8]            ;759
00004c  2308              MOVS     r3,#8                 ;760
00004e  e017              B        |L30.128|
                  |L30.80|
000050  4661              MOV      r1,r12                ;764
000052  0a0a              LSRS     r2,r1,#8              ;764
000054  6082              STR      r2,[r0,#8]            ;764
000056  e013              B        |L30.128|
                  |L30.88|
000058  2318              MOVS     r3,#0x18              ;769
                  |L30.90|
00005a  2501              MOVS     r5,#1                 ;770
00005c  e010              B        |L30.128|
                  |L30.94|
00005e  2e00              CMP      r6,#0                 ;774
000060  d004              BEQ      |L30.108|
000062  4661              MOV      r1,r12                ;776
000064  b2c9              UXTB     r1,r1                 ;776
000066  6081              STR      r1,[r0,#8]            ;776
000068  2600              MOVS     r6,#0                 ;777
00006a  e009              B        |L30.128|
                  |L30.108|
00006c  9a09              LDR      r2,[sp,#0x24]         ;779
00006e  4294              CMP      r4,r2                 ;779
000070  d204              BCS      |L30.124|
000072  9a03              LDR      r2,[sp,#0xc]          ;780
000074  5d12              LDRB     r2,[r2,r4]            ;780
000076  6082              STR      r2,[r0,#8]            ;780
000078  1c64              ADDS     r4,r4,#1              ;780
00007a  e001              B        |L30.128|
                  |L30.124|
00007c  2318              MOVS     r3,#0x18              ;783
00007e  2700              MOVS     r7,#0                 ;784
                  |L30.128|
;;;795            }
;;;796    
;;;797            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000080  6801              LDR      r1,[r0,#0]
000082  223c              MOVS     r2,#0x3c
000084  4391              BICS     r1,r1,r2
000086  460a              MOV      r2,r1
000088  431a              ORRS     r2,r2,r3
00008a  6002              STR      r2,[r0,#0]
00008c  2f00              CMP      r7,#0                 ;752
00008e  d001              BEQ      |L30.148|
000090  2d00              CMP      r5,#0                 ;752
000092  d0c1              BEQ      |L30.24|
                  |L30.148|
;;;798        }
;;;799    
;;;800        return u32txLen;                                                        /* Return bytes length that have been transmitted */
000094  4620              MOV      r0,r4
;;;801    }
000096  b004              ADD      sp,sp,#0x10
000098  bdf0              POP      {r4-r7,pc}
;;;802    
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L187.16|
00000e  461d              MOV      r5,r3
                  |L187.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 479
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
